"export type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: { input: string; output: string; }\n  String: { input: string; output: string; }\n  Boolean: { input: boolean; output: boolean; }\n  Int: { input: number; output: number; }\n  Float: { input: number; output: number; }\n  application_status: { input: any; output: any; }\n  bigint: { input: any; output: any; }\n  jsonb: { input: any; output: any; }\n  numeric: { input: any; output: any; }\n  project_role_name: { input: any; output: any; }\n  project_type: { input: any; output: any; }\n  round_role_name: { input: any; output: any; }\n  timestamptz: { input: any; output: any; }\n};\n\n/** Boolean expression to compare columns of type \"application_status\". All fields are combined with logical 'AND'. */\nexport type ApplicationStatusComparisonExp = {\n  _eq?: InputMaybe<Scalars['application_status']['input']>;\n  _gt?: InputMaybe<Scalars['application_status']['input']>;\n  _gte?: InputMaybe<Scalars['application_status']['input']>;\n  _in?: InputMaybe<Array<Scalars['application_status']['input']>>;\n  _isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  _lt?: InputMaybe<Scalars['application_status']['input']>;\n  _lte?: InputMaybe<Scalars['application_status']['input']>;\n  _neq?: InputMaybe<Scalars['application_status']['input']>;\n  _nin?: InputMaybe<Array<Scalars['application_status']['input']>>;\n};\n\n/** columns and relationships of \"applications\" */\nexport type Applications = {\n  __typename?: 'Applications';\n  anchorAddress?: Maybe<Scalars['String']['output']>;\n  /** An array relationship */\n  applicationsPayouts: Array<ApplicationsPayouts>;\n  /** An aggregate relationship */\n  applicationsPayoutsAggregate: ApplicationsPayoutsAggregate;\n  chainId: Scalars['Int']['output'];\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  createdByAddress?: Maybe<Scalars['String']['output']>;\n  distributionTransaction?: Maybe<Scalars['String']['output']>;\n  /** An array relationship */\n  donations: Array<Donations>;\n  /** An aggregate relationship */\n  donationsAggregate: DonationsAggregate;\n  id: Scalars['String']['output'];\n  metadata?: Maybe<Scalars['jsonb']['output']>;\n  metadataCid?: Maybe<Scalars['String']['output']>;\n  /** An object relationship */\n  project?: Maybe<Projects>;\n  projectId?: Maybe<Scalars['String']['output']>;\n  /** An array relationship */\n  projects: Array<Projects>;\n  /** An aggregate relationship */\n  projectsAggregate: ProjectsAggregate;\n  /** An object relationship */\n  round?: Maybe<Rounds>;\n  roundId: Scalars['String']['output'];\n  status?: Maybe<Scalars['application_status']['output']>;\n  statusSnapshots?: Maybe<Scalars['jsonb']['output']>;\n  statusUpdatedAtBlock?: Maybe<Scalars['numeric']['output']>;\n  tags?: Maybe<Scalars['jsonb']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['numeric']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Int']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Int']['output']>;\n};\n\n\n/** columns and relationships of \"applications\" */\nexport type ApplicationsApplicationsPayoutsArgs = {\n  distinctOn?: InputMaybe<Array<ApplicationsPayoutsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ApplicationsPayoutsOrderBy>>;\n  where?: InputMaybe<ApplicationsPayoutsBoolExp>;\n};\n\n\n/** columns and relationships of \"applications\" */\nexport type ApplicationsApplicationsPayoutsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<ApplicationsPayoutsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ApplicationsPayoutsOrderBy>>;\n  where?: InputMaybe<ApplicationsPayoutsBoolExp>;\n};\n\n\n/** columns and relationships of \"applications\" */\nexport type ApplicationsDonationsArgs = {\n  distinctOn?: InputMaybe<Array<DonationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<DonationsOrderBy>>;\n  where?: InputMaybe<DonationsBoolExp>;\n};\n\n\n/** columns and relationships of \"applications\" */\nexport type ApplicationsDonationsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<DonationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<DonationsOrderBy>>;\n  where?: InputMaybe<DonationsBoolExp>;\n};\n\n\n/** columns and relationships of \"applications\" */\nexport type ApplicationsMetadataArgs = {\n  path?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** columns and relationships of \"applications\" */\nexport type ApplicationsProjectsArgs = {\n  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;\n  where?: InputMaybe<ProjectsBoolExp>;\n};\n\n\n/** columns and relationships of \"applications\" */\nexport type ApplicationsProjectsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;\n  where?: InputMaybe<ProjectsBoolExp>;\n};\n\n\n/** columns and relationships of \"applications\" */\nexport type ApplicationsStatusSnapshotsArgs = {\n  path?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** columns and relationships of \"applications\" */\nexport type ApplicationsTagsArgs = {\n  path?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** aggregated selection of \"applications\" */\nexport type ApplicationsAggregate = {\n  __typename?: 'ApplicationsAggregate';\n  aggregate?: Maybe<ApplicationsAggregateFields>;\n  nodes: Array<Applications>;\n};\n\nexport type ApplicationsAggregateBoolExp = {\n  count?: InputMaybe<ApplicationsAggregateBoolExpCount>;\n};\n\n/** aggregate fields of \"applications\" */\nexport type ApplicationsAggregateFields = {\n  __typename?: 'ApplicationsAggregateFields';\n  avg?: Maybe<ApplicationsAvgFields>;\n  count: Scalars['Int']['output'];\n  max?: Maybe<ApplicationsMaxFields>;\n  min?: Maybe<ApplicationsMinFields>;\n  stddev?: Maybe<ApplicationsStddevFields>;\n  stddevPop?: Maybe<ApplicationsStddevPopFields>;\n  stddevSamp?: Maybe<ApplicationsStddevSampFields>;\n  sum?: Maybe<ApplicationsSumFields>;\n  varPop?: Maybe<ApplicationsVarPopFields>;\n  varSamp?: Maybe<ApplicationsVarSampFields>;\n  variance?: Maybe<ApplicationsVarianceFields>;\n};\n\n\n/** aggregate fields of \"applications\" */\nexport type ApplicationsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<ApplicationsSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** order by aggregate values of table \"applications\" */\nexport type ApplicationsAggregateOrderBy = {\n  avg?: InputMaybe<ApplicationsAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<ApplicationsMaxOrderBy>;\n  min?: InputMaybe<ApplicationsMinOrderBy>;\n  stddev?: InputMaybe<ApplicationsStddevOrderBy>;\n  stddevPop?: InputMaybe<ApplicationsStddevPopOrderBy>;\n  stddevSamp?: InputMaybe<ApplicationsStddevSampOrderBy>;\n  sum?: InputMaybe<ApplicationsSumOrderBy>;\n  varPop?: InputMaybe<ApplicationsVarPopOrderBy>;\n  varSamp?: InputMaybe<ApplicationsVarSampOrderBy>;\n  variance?: InputMaybe<ApplicationsVarianceOrderBy>;\n};\n\n/** aggregate avg on columns */\nexport type ApplicationsAvgFields = {\n  __typename?: 'ApplicationsAvgFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  statusUpdatedAtBlock?: Maybe<Scalars['Float']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['Float']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Float']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by avg() on columns of table \"applications\" */\nexport type ApplicationsAvgOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  statusUpdatedAtBlock?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"applications\". All fields are combined with a logical 'AND'. */\nexport type ApplicationsBoolExp = {\n  _and?: InputMaybe<Array<ApplicationsBoolExp>>;\n  _not?: InputMaybe<ApplicationsBoolExp>;\n  _or?: InputMaybe<Array<ApplicationsBoolExp>>;\n  anchorAddress?: InputMaybe<StringComparisonExp>;\n  applicationsPayouts?: InputMaybe<ApplicationsPayoutsBoolExp>;\n  applicationsPayoutsAggregate?: InputMaybe<ApplicationsPayoutsAggregateBoolExp>;\n  chainId?: InputMaybe<IntComparisonExp>;\n  createdAtBlock?: InputMaybe<NumericComparisonExp>;\n  createdByAddress?: InputMaybe<StringComparisonExp>;\n  distributionTransaction?: InputMaybe<StringComparisonExp>;\n  donations?: InputMaybe<DonationsBoolExp>;\n  donationsAggregate?: InputMaybe<DonationsAggregateBoolExp>;\n  id?: InputMaybe<StringComparisonExp>;\n  metadata?: InputMaybe<JsonbComparisonExp>;\n  metadataCid?: InputMaybe<StringComparisonExp>;\n  project?: InputMaybe<ProjectsBoolExp>;\n  projectId?: InputMaybe<StringComparisonExp>;\n  projects?: InputMaybe<ProjectsBoolExp>;\n  projectsAggregate?: InputMaybe<ProjectsAggregateBoolExp>;\n  round?: InputMaybe<RoundsBoolExp>;\n  roundId?: InputMaybe<StringComparisonExp>;\n  status?: InputMaybe<ApplicationStatusComparisonExp>;\n  statusSnapshots?: InputMaybe<JsonbComparisonExp>;\n  statusUpdatedAtBlock?: InputMaybe<NumericComparisonExp>;\n  tags?: InputMaybe<JsonbComparisonExp>;\n  timestamp?: InputMaybe<TimestamptzComparisonExp>;\n  totalAmountDonatedInUsd?: InputMaybe<NumericComparisonExp>;\n  totalDonationsCount?: InputMaybe<IntComparisonExp>;\n  uniqueDonorsCount?: InputMaybe<IntComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type ApplicationsMaxFields = {\n  __typename?: 'ApplicationsMaxFields';\n  anchorAddress?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  createdByAddress?: Maybe<Scalars['String']['output']>;\n  distributionTransaction?: Maybe<Scalars['String']['output']>;\n  id?: Maybe<Scalars['String']['output']>;\n  metadataCid?: Maybe<Scalars['String']['output']>;\n  projectId?: Maybe<Scalars['String']['output']>;\n  roundId?: Maybe<Scalars['String']['output']>;\n  status?: Maybe<Scalars['application_status']['output']>;\n  statusUpdatedAtBlock?: Maybe<Scalars['numeric']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['numeric']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Int']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Int']['output']>;\n};\n\n/** order by max() on columns of table \"applications\" */\nexport type ApplicationsMaxOrderBy = {\n  anchorAddress?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  createdByAddress?: InputMaybe<OrderBy>;\n  distributionTransaction?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  metadataCid?: InputMaybe<OrderBy>;\n  projectId?: InputMaybe<OrderBy>;\n  roundId?: InputMaybe<OrderBy>;\n  status?: InputMaybe<OrderBy>;\n  statusUpdatedAtBlock?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type ApplicationsMinFields = {\n  __typename?: 'ApplicationsMinFields';\n  anchorAddress?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  createdByAddress?: Maybe<Scalars['String']['output']>;\n  distributionTransaction?: Maybe<Scalars['String']['output']>;\n  id?: Maybe<Scalars['String']['output']>;\n  metadataCid?: Maybe<Scalars['String']['output']>;\n  projectId?: Maybe<Scalars['String']['output']>;\n  roundId?: Maybe<Scalars['String']['output']>;\n  status?: Maybe<Scalars['application_status']['output']>;\n  statusUpdatedAtBlock?: Maybe<Scalars['numeric']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['numeric']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Int']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Int']['output']>;\n};\n\n/** order by min() on columns of table \"applications\" */\nexport type ApplicationsMinOrderBy = {\n  anchorAddress?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  createdByAddress?: InputMaybe<OrderBy>;\n  distributionTransaction?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  metadataCid?: InputMaybe<OrderBy>;\n  projectId?: InputMaybe<OrderBy>;\n  roundId?: InputMaybe<OrderBy>;\n  status?: InputMaybe<OrderBy>;\n  statusUpdatedAtBlock?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"applications\". */\nexport type ApplicationsOrderBy = {\n  anchorAddress?: InputMaybe<OrderBy>;\n  applicationsPayoutsAggregate?: InputMaybe<ApplicationsPayoutsAggregateOrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  createdByAddress?: InputMaybe<OrderBy>;\n  distributionTransaction?: InputMaybe<OrderBy>;\n  donationsAggregate?: InputMaybe<DonationsAggregateOrderBy>;\n  id?: InputMaybe<OrderBy>;\n  metadata?: InputMaybe<OrderBy>;\n  metadataCid?: InputMaybe<OrderBy>;\n  project?: InputMaybe<ProjectsOrderBy>;\n  projectId?: InputMaybe<OrderBy>;\n  projectsAggregate?: InputMaybe<ProjectsAggregateOrderBy>;\n  round?: InputMaybe<RoundsOrderBy>;\n  roundId?: InputMaybe<OrderBy>;\n  status?: InputMaybe<OrderBy>;\n  statusSnapshots?: InputMaybe<OrderBy>;\n  statusUpdatedAtBlock?: InputMaybe<OrderBy>;\n  tags?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"applications_payouts\" */\nexport type ApplicationsPayouts = {\n  __typename?: 'ApplicationsPayouts';\n  amount?: Maybe<Scalars['numeric']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['numeric']['output']>;\n  amountInUsd?: Maybe<Scalars['numeric']['output']>;\n  /** An object relationship */\n  application?: Maybe<Applications>;\n  applicationId?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  id: Scalars['Int']['output'];\n  roundId?: Maybe<Scalars['String']['output']>;\n  sender?: Maybe<Scalars['String']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  tokenAddress?: Maybe<Scalars['String']['output']>;\n  transactionHash?: Maybe<Scalars['String']['output']>;\n};\n\n/** aggregated selection of \"applications_payouts\" */\nexport type ApplicationsPayoutsAggregate = {\n  __typename?: 'ApplicationsPayoutsAggregate';\n  aggregate?: Maybe<ApplicationsPayoutsAggregateFields>;\n  nodes: Array<ApplicationsPayouts>;\n};\n\nexport type ApplicationsPayoutsAggregateBoolExp = {\n  count?: InputMaybe<ApplicationsPayoutsAggregateBoolExpCount>;\n};\n\n/** aggregate fields of \"applications_payouts\" */\nexport type ApplicationsPayoutsAggregateFields = {\n  __typename?: 'ApplicationsPayoutsAggregateFields';\n  avg?: Maybe<ApplicationsPayoutsAvgFields>;\n  count: Scalars['Int']['output'];\n  max?: Maybe<ApplicationsPayoutsMaxFields>;\n  min?: Maybe<ApplicationsPayoutsMinFields>;\n  stddev?: Maybe<ApplicationsPayoutsStddevFields>;\n  stddevPop?: Maybe<ApplicationsPayoutsStddevPopFields>;\n  stddevSamp?: Maybe<ApplicationsPayoutsStddevSampFields>;\n  sum?: Maybe<ApplicationsPayoutsSumFields>;\n  varPop?: Maybe<ApplicationsPayoutsVarPopFields>;\n  varSamp?: Maybe<ApplicationsPayoutsVarSampFields>;\n  variance?: Maybe<ApplicationsPayoutsVarianceFields>;\n};\n\n\n/** aggregate fields of \"applications_payouts\" */\nexport type ApplicationsPayoutsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<ApplicationsPayoutsSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** order by aggregate values of table \"applications_payouts\" */\nexport type ApplicationsPayoutsAggregateOrderBy = {\n  avg?: InputMaybe<ApplicationsPayoutsAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<ApplicationsPayoutsMaxOrderBy>;\n  min?: InputMaybe<ApplicationsPayoutsMinOrderBy>;\n  stddev?: InputMaybe<ApplicationsPayoutsStddevOrderBy>;\n  stddevPop?: InputMaybe<ApplicationsPayoutsStddevPopOrderBy>;\n  stddevSamp?: InputMaybe<ApplicationsPayoutsStddevSampOrderBy>;\n  sum?: InputMaybe<ApplicationsPayoutsSumOrderBy>;\n  varPop?: InputMaybe<ApplicationsPayoutsVarPopOrderBy>;\n  varSamp?: InputMaybe<ApplicationsPayoutsVarSampOrderBy>;\n  variance?: InputMaybe<ApplicationsPayoutsVarianceOrderBy>;\n};\n\n/** aggregate avg on columns */\nexport type ApplicationsPayoutsAvgFields = {\n  __typename?: 'ApplicationsPayoutsAvgFields';\n  amount?: Maybe<Scalars['Float']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['Float']['output']>;\n  amountInUsd?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by avg() on columns of table \"applications_payouts\" */\nexport type ApplicationsPayoutsAvgOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"applications_payouts\". All fields are combined with a logical 'AND'. */\nexport type ApplicationsPayoutsBoolExp = {\n  _and?: InputMaybe<Array<ApplicationsPayoutsBoolExp>>;\n  _not?: InputMaybe<ApplicationsPayoutsBoolExp>;\n  _or?: InputMaybe<Array<ApplicationsPayoutsBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  amountInRoundMatchToken?: InputMaybe<NumericComparisonExp>;\n  amountInUsd?: InputMaybe<NumericComparisonExp>;\n  application?: InputMaybe<ApplicationsBoolExp>;\n  applicationId?: InputMaybe<StringComparisonExp>;\n  chainId?: InputMaybe<IntComparisonExp>;\n  id?: InputMaybe<IntComparisonExp>;\n  roundId?: InputMaybe<StringComparisonExp>;\n  sender?: InputMaybe<StringComparisonExp>;\n  timestamp?: InputMaybe<TimestamptzComparisonExp>;\n  tokenAddress?: InputMaybe<StringComparisonExp>;\n  transactionHash?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type ApplicationsPayoutsMaxFields = {\n  __typename?: 'ApplicationsPayoutsMaxFields';\n  amount?: Maybe<Scalars['numeric']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['numeric']['output']>;\n  amountInUsd?: Maybe<Scalars['numeric']['output']>;\n  applicationId?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  id?: Maybe<Scalars['Int']['output']>;\n  roundId?: Maybe<Scalars['String']['output']>;\n  sender?: Maybe<Scalars['String']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  tokenAddress?: Maybe<Scalars['String']['output']>;\n  transactionHash?: Maybe<Scalars['String']['output']>;\n};\n\n/** order by max() on columns of table \"applications_payouts\" */\nexport type ApplicationsPayoutsMaxOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  applicationId?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  roundId?: InputMaybe<OrderBy>;\n  sender?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  tokenAddress?: InputMaybe<OrderBy>;\n  transactionHash?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type ApplicationsPayoutsMinFields = {\n  __typename?: 'ApplicationsPayoutsMinFields';\n  amount?: Maybe<Scalars['numeric']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['numeric']['output']>;\n  amountInUsd?: Maybe<Scalars['numeric']['output']>;\n  applicationId?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  id?: Maybe<Scalars['Int']['output']>;\n  roundId?: Maybe<Scalars['String']['output']>;\n  sender?: Maybe<Scalars['String']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  tokenAddress?: Maybe<Scalars['String']['output']>;\n  transactionHash?: Maybe<Scalars['String']['output']>;\n};\n\n/** order by min() on columns of table \"applications_payouts\" */\nexport type ApplicationsPayoutsMinOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  applicationId?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  roundId?: InputMaybe<OrderBy>;\n  sender?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  tokenAddress?: InputMaybe<OrderBy>;\n  transactionHash?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"applications_payouts\". */\nexport type ApplicationsPayoutsOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  application?: InputMaybe<ApplicationsOrderBy>;\n  applicationId?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  roundId?: InputMaybe<OrderBy>;\n  sender?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  tokenAddress?: InputMaybe<OrderBy>;\n  transactionHash?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"applications_payouts\" */\nexport enum ApplicationsPayoutsSelectColumn {\n  /** column name */\n  Amount = 'amount',\n  /** column name */\n  AmountInRoundMatchToken = 'amountInRoundMatchToken',\n  /** column name */\n  AmountInUsd = 'amountInUsd',\n  /** column name */\n  ApplicationId = 'applicationId',\n  /** column name */\n  ChainId = 'chainId',\n  /** column name */\n  Id = 'id',\n  /** column name */\n  RoundId = 'roundId',\n  /** column name */\n  Sender = 'sender',\n  /** column name */\n  Timestamp = 'timestamp',\n  /** column name */\n  TokenAddress = 'tokenAddress',\n  /** column name */\n  TransactionHash = 'transactionHash'\n}\n\n/** aggregate stddev on columns */\nexport type ApplicationsPayoutsStddevFields = {\n  __typename?: 'ApplicationsPayoutsStddevFields';\n  amount?: Maybe<Scalars['Float']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['Float']['output']>;\n  amountInUsd?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddev() on columns of table \"applications_payouts\" */\nexport type ApplicationsPayoutsStddevOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevPop on columns */\nexport type ApplicationsPayoutsStddevPopFields = {\n  __typename?: 'ApplicationsPayoutsStddevPopFields';\n  amount?: Maybe<Scalars['Float']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['Float']['output']>;\n  amountInUsd?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevPop() on columns of table \"applications_payouts\" */\nexport type ApplicationsPayoutsStddevPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevSamp on columns */\nexport type ApplicationsPayoutsStddevSampFields = {\n  __typename?: 'ApplicationsPayoutsStddevSampFields';\n  amount?: Maybe<Scalars['Float']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['Float']['output']>;\n  amountInUsd?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevSamp() on columns of table \"applications_payouts\" */\nexport type ApplicationsPayoutsStddevSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"applications_payouts\" */\nexport type ApplicationsPayoutsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initialValue: ApplicationsPayoutsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type ApplicationsPayoutsStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars['numeric']['input']>;\n  amountInRoundMatchToken?: InputMaybe<Scalars['numeric']['input']>;\n  amountInUsd?: InputMaybe<Scalars['numeric']['input']>;\n  applicationId?: InputMaybe<Scalars['String']['input']>;\n  chainId?: InputMaybe<Scalars['Int']['input']>;\n  id?: InputMaybe<Scalars['Int']['input']>;\n  roundId?: InputMaybe<Scalars['String']['input']>;\n  sender?: InputMaybe<Scalars['String']['input']>;\n  timestamp?: InputMaybe<Scalars['timestamptz']['input']>;\n  tokenAddress?: InputMaybe<Scalars['String']['input']>;\n  transactionHash?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** aggregate sum on columns */\nexport type ApplicationsPayoutsSumFields = {\n  __typename?: 'ApplicationsPayoutsSumFields';\n  amount?: Maybe<Scalars['numeric']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['numeric']['output']>;\n  amountInUsd?: Maybe<Scalars['numeric']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  id?: Maybe<Scalars['Int']['output']>;\n};\n\n/** order by sum() on columns of table \"applications_payouts\" */\nexport type ApplicationsPayoutsSumOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varPop on columns */\nexport type ApplicationsPayoutsVarPopFields = {\n  __typename?: 'ApplicationsPayoutsVarPopFields';\n  amount?: Maybe<Scalars['Float']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['Float']['output']>;\n  amountInUsd?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varPop() on columns of table \"applications_payouts\" */\nexport type ApplicationsPayoutsVarPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varSamp on columns */\nexport type ApplicationsPayoutsVarSampFields = {\n  __typename?: 'ApplicationsPayoutsVarSampFields';\n  amount?: Maybe<Scalars['Float']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['Float']['output']>;\n  amountInUsd?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varSamp() on columns of table \"applications_payouts\" */\nexport type ApplicationsPayoutsVarSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type ApplicationsPayoutsVarianceFields = {\n  __typename?: 'ApplicationsPayoutsVarianceFields';\n  amount?: Maybe<Scalars['Float']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['Float']['output']>;\n  amountInUsd?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by variance() on columns of table \"applications_payouts\" */\nexport type ApplicationsPayoutsVarianceOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"applications\" */\nexport enum ApplicationsSelectColumn {\n  /** column name */\n  AnchorAddress = 'anchorAddress',\n  /** column name */\n  ChainId = 'chainId',\n  /** column name */\n  CreatedAtBlock = 'createdAtBlock',\n  /** column name */\n  CreatedByAddress = 'createdByAddress',\n  /** column name */\n  DistributionTransaction = 'distributionTransaction',\n  /** column name */\n  Id = 'id',\n  /** column name */\n  Metadata = 'metadata',\n  /** column name */\n  MetadataCid = 'metadataCid',\n  /** column name */\n  ProjectId = 'projectId',\n  /** column name */\n  RoundId = 'roundId',\n  /** column name */\n  Status = 'status',\n  /** column name */\n  StatusSnapshots = 'statusSnapshots',\n  /** column name */\n  StatusUpdatedAtBlock = 'statusUpdatedAtBlock',\n  /** column name */\n  Tags = 'tags',\n  /** column name */\n  Timestamp = 'timestamp',\n  /** column name */\n  TotalAmountDonatedInUsd = 'totalAmountDonatedInUsd',\n  /** column name */\n  TotalDonationsCount = 'totalDonationsCount',\n  /** column name */\n  UniqueDonorsCount = 'uniqueDonorsCount'\n}\n\n/** aggregate stddev on columns */\nexport type ApplicationsStddevFields = {\n  __typename?: 'ApplicationsStddevFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  statusUpdatedAtBlock?: Maybe<Scalars['Float']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['Float']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Float']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddev() on columns of table \"applications\" */\nexport type ApplicationsStddevOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  statusUpdatedAtBlock?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevPop on columns */\nexport type ApplicationsStddevPopFields = {\n  __typename?: 'ApplicationsStddevPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  statusUpdatedAtBlock?: Maybe<Scalars['Float']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['Float']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Float']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevPop() on columns of table \"applications\" */\nexport type ApplicationsStddevPopOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  statusUpdatedAtBlock?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevSamp on columns */\nexport type ApplicationsStddevSampFields = {\n  __typename?: 'ApplicationsStddevSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  statusUpdatedAtBlock?: Maybe<Scalars['Float']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['Float']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Float']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevSamp() on columns of table \"applications\" */\nexport type ApplicationsStddevSampOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  statusUpdatedAtBlock?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"applications\" */\nexport type ApplicationsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initialValue: ApplicationsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type ApplicationsStreamCursorValueInput = {\n  anchorAddress?: InputMaybe<Scalars['String']['input']>;\n  chainId?: InputMaybe<Scalars['Int']['input']>;\n  createdAtBlock?: InputMaybe<Scalars['numeric']['input']>;\n  createdByAddress?: InputMaybe<Scalars['String']['input']>;\n  distributionTransaction?: InputMaybe<Scalars['String']['input']>;\n  id?: InputMaybe<Scalars['String']['input']>;\n  metadata?: InputMaybe<Scalars['jsonb']['input']>;\n  metadataCid?: InputMaybe<Scalars['String']['input']>;\n  projectId?: InputMaybe<Scalars['String']['input']>;\n  roundId?: InputMaybe<Scalars['String']['input']>;\n  status?: InputMaybe<Scalars['application_status']['input']>;\n  statusSnapshots?: InputMaybe<Scalars['jsonb']['input']>;\n  statusUpdatedAtBlock?: InputMaybe<Scalars['numeric']['input']>;\n  tags?: InputMaybe<Scalars['jsonb']['input']>;\n  timestamp?: InputMaybe<Scalars['timestamptz']['input']>;\n  totalAmountDonatedInUsd?: InputMaybe<Scalars['numeric']['input']>;\n  totalDonationsCount?: InputMaybe<Scalars['Int']['input']>;\n  uniqueDonorsCount?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** aggregate sum on columns */\nexport type ApplicationsSumFields = {\n  __typename?: 'ApplicationsSumFields';\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  statusUpdatedAtBlock?: Maybe<Scalars['numeric']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['numeric']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Int']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Int']['output']>;\n};\n\n/** order by sum() on columns of table \"applications\" */\nexport type ApplicationsSumOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  statusUpdatedAtBlock?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varPop on columns */\nexport type ApplicationsVarPopFields = {\n  __typename?: 'ApplicationsVarPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  statusUpdatedAtBlock?: Maybe<Scalars['Float']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['Float']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Float']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varPop() on columns of table \"applications\" */\nexport type ApplicationsVarPopOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  statusUpdatedAtBlock?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varSamp on columns */\nexport type ApplicationsVarSampFields = {\n  __typename?: 'ApplicationsVarSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  statusUpdatedAtBlock?: Maybe<Scalars['Float']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['Float']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Float']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varSamp() on columns of table \"applications\" */\nexport type ApplicationsVarSampOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  statusUpdatedAtBlock?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type ApplicationsVarianceFields = {\n  __typename?: 'ApplicationsVarianceFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  statusUpdatedAtBlock?: Maybe<Scalars['Float']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['Float']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Float']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by variance() on columns of table \"applications\" */\nexport type ApplicationsVarianceOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  statusUpdatedAtBlock?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"attestation_txns\" */\nexport type AttestationTxns = {\n  __typename?: 'AttestationTxns';\n  /** An object relationship */\n  attestation?: Maybe<Attestations>;\n  attestationChainId?: Maybe<Scalars['Int']['output']>;\n  attestationUid?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  /** An object relationship */\n  donation?: Maybe<Donations>;\n  txnHash?: Maybe<Scalars['String']['output']>;\n};\n\n/** aggregated selection of \"attestation_txns\" */\nexport type AttestationTxnsAggregate = {\n  __typename?: 'AttestationTxnsAggregate';\n  aggregate?: Maybe<AttestationTxnsAggregateFields>;\n  nodes: Array<AttestationTxns>;\n};\n\nexport type AttestationTxnsAggregateBoolExp = {\n  count?: InputMaybe<AttestationTxnsAggregateBoolExpCount>;\n};\n\n/** aggregate fields of \"attestation_txns\" */\nexport type AttestationTxnsAggregateFields = {\n  __typename?: 'AttestationTxnsAggregateFields';\n  avg?: Maybe<AttestationTxnsAvgFields>;\n  count: Scalars['Int']['output'];\n  max?: Maybe<AttestationTxnsMaxFields>;\n  min?: Maybe<AttestationTxnsMinFields>;\n  stddev?: Maybe<AttestationTxnsStddevFields>;\n  stddevPop?: Maybe<AttestationTxnsStddevPopFields>;\n  stddevSamp?: Maybe<AttestationTxnsStddevSampFields>;\n  sum?: Maybe<AttestationTxnsSumFields>;\n  varPop?: Maybe<AttestationTxnsVarPopFields>;\n  varSamp?: Maybe<AttestationTxnsVarSampFields>;\n  variance?: Maybe<AttestationTxnsVarianceFields>;\n};\n\n\n/** aggregate fields of \"attestation_txns\" */\nexport type AttestationTxnsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<AttestationTxnsSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** order by aggregate values of table \"attestation_txns\" */\nexport type AttestationTxnsAggregateOrderBy = {\n  avg?: InputMaybe<AttestationTxnsAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<AttestationTxnsMaxOrderBy>;\n  min?: InputMaybe<AttestationTxnsMinOrderBy>;\n  stddev?: InputMaybe<AttestationTxnsStddevOrderBy>;\n  stddevPop?: InputMaybe<AttestationTxnsStddevPopOrderBy>;\n  stddevSamp?: InputMaybe<AttestationTxnsStddevSampOrderBy>;\n  sum?: InputMaybe<AttestationTxnsSumOrderBy>;\n  varPop?: InputMaybe<AttestationTxnsVarPopOrderBy>;\n  varSamp?: InputMaybe<AttestationTxnsVarSampOrderBy>;\n  variance?: InputMaybe<AttestationTxnsVarianceOrderBy>;\n};\n\n/** aggregate avg on columns */\nexport type AttestationTxnsAvgFields = {\n  __typename?: 'AttestationTxnsAvgFields';\n  attestationChainId?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by avg() on columns of table \"attestation_txns\" */\nexport type AttestationTxnsAvgOrderBy = {\n  attestationChainId?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"attestation_txns\". All fields are combined with a logical 'AND'. */\nexport type AttestationTxnsBoolExp = {\n  _and?: InputMaybe<Array<AttestationTxnsBoolExp>>;\n  _not?: InputMaybe<AttestationTxnsBoolExp>;\n  _or?: InputMaybe<Array<AttestationTxnsBoolExp>>;\n  attestation?: InputMaybe<AttestationsBoolExp>;\n  attestationChainId?: InputMaybe<IntComparisonExp>;\n  attestationUid?: InputMaybe<StringComparisonExp>;\n  chainId?: InputMaybe<IntComparisonExp>;\n  donation?: InputMaybe<DonationsBoolExp>;\n  txnHash?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type AttestationTxnsMaxFields = {\n  __typename?: 'AttestationTxnsMaxFields';\n  attestationChainId?: Maybe<Scalars['Int']['output']>;\n  attestationUid?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  txnHash?: Maybe<Scalars['String']['output']>;\n};\n\n/** order by max() on columns of table \"attestation_txns\" */\nexport type AttestationTxnsMaxOrderBy = {\n  attestationChainId?: InputMaybe<OrderBy>;\n  attestationUid?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  txnHash?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type AttestationTxnsMinFields = {\n  __typename?: 'AttestationTxnsMinFields';\n  attestationChainId?: Maybe<Scalars['Int']['output']>;\n  attestationUid?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  txnHash?: Maybe<Scalars['String']['output']>;\n};\n\n/** order by min() on columns of table \"attestation_txns\" */\nexport type AttestationTxnsMinOrderBy = {\n  attestationChainId?: InputMaybe<OrderBy>;\n  attestationUid?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  txnHash?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"attestation_txns\". */\nexport type AttestationTxnsOrderBy = {\n  attestation?: InputMaybe<AttestationsOrderBy>;\n  attestationChainId?: InputMaybe<OrderBy>;\n  attestationUid?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  donation?: InputMaybe<DonationsOrderBy>;\n  txnHash?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"attestation_txns\" */\nexport enum AttestationTxnsSelectColumn {\n  /** column name */\n  AttestationChainId = 'attestationChainId',\n  /** column name */\n  AttestationUid = 'attestationUid',\n  /** column name */\n  ChainId = 'chainId',\n  /** column name */\n  TxnHash = 'txnHash'\n}\n\n/** aggregate stddev on columns */\nexport type AttestationTxnsStddevFields = {\n  __typename?: 'AttestationTxnsStddevFields';\n  attestationChainId?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddev() on columns of table \"attestation_txns\" */\nexport type AttestationTxnsStddevOrderBy = {\n  attestationChainId?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevPop on columns */\nexport type AttestationTxnsStddevPopFields = {\n  __typename?: 'AttestationTxnsStddevPopFields';\n  attestationChainId?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevPop() on columns of table \"attestation_txns\" */\nexport type AttestationTxnsStddevPopOrderBy = {\n  attestationChainId?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevSamp on columns */\nexport type AttestationTxnsStddevSampFields = {\n  __typename?: 'AttestationTxnsStddevSampFields';\n  attestationChainId?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevSamp() on columns of table \"attestation_txns\" */\nexport type AttestationTxnsStddevSampOrderBy = {\n  attestationChainId?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"attestation_txns\" */\nexport type AttestationTxnsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initialValue: AttestationTxnsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type AttestationTxnsStreamCursorValueInput = {\n  attestationChainId?: InputMaybe<Scalars['Int']['input']>;\n  attestationUid?: InputMaybe<Scalars['String']['input']>;\n  chainId?: InputMaybe<Scalars['Int']['input']>;\n  txnHash?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** aggregate sum on columns */\nexport type AttestationTxnsSumFields = {\n  __typename?: 'AttestationTxnsSumFields';\n  attestationChainId?: Maybe<Scalars['Int']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n};\n\n/** order by sum() on columns of table \"attestation_txns\" */\nexport type AttestationTxnsSumOrderBy = {\n  attestationChainId?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varPop on columns */\nexport type AttestationTxnsVarPopFields = {\n  __typename?: 'AttestationTxnsVarPopFields';\n  attestationChainId?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varPop() on columns of table \"attestation_txns\" */\nexport type AttestationTxnsVarPopOrderBy = {\n  attestationChainId?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varSamp on columns */\nexport type AttestationTxnsVarSampFields = {\n  __typename?: 'AttestationTxnsVarSampFields';\n  attestationChainId?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varSamp() on columns of table \"attestation_txns\" */\nexport type AttestationTxnsVarSampOrderBy = {\n  attestationChainId?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type AttestationTxnsVarianceFields = {\n  __typename?: 'AttestationTxnsVarianceFields';\n  attestationChainId?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by variance() on columns of table \"attestation_txns\" */\nexport type AttestationTxnsVarianceOrderBy = {\n  attestationChainId?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"attestations\" */\nexport type Attestations = {\n  __typename?: 'Attestations';\n  /** An array relationship */\n  attestationTxns: Array<AttestationTxns>;\n  /** An aggregate relationship */\n  attestationTxnsAggregate: AttestationTxnsAggregate;\n  chainId: Scalars['Int']['output'];\n  chainIdsContributed?: Maybe<Scalars['numeric']['output']>;\n  fee?: Maybe<Scalars['numeric']['output']>;\n  metadata?: Maybe<Scalars['jsonb']['output']>;\n  metadataCid?: Maybe<Scalars['String']['output']>;\n  projectsContributed?: Maybe<Scalars['numeric']['output']>;\n  recipient?: Maybe<Scalars['String']['output']>;\n  refUid?: Maybe<Scalars['String']['output']>;\n  roundsContributed?: Maybe<Scalars['numeric']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  totalUsdamount?: Maybe<Scalars['numeric']['output']>;\n  uid: Scalars['String']['output'];\n};\n\n\n/** columns and relationships of \"attestations\" */\nexport type AttestationsAttestationTxnsArgs = {\n  distinctOn?: InputMaybe<Array<AttestationTxnsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<AttestationTxnsOrderBy>>;\n  where?: InputMaybe<AttestationTxnsBoolExp>;\n};\n\n\n/** columns and relationships of \"attestations\" */\nexport type AttestationsAttestationTxnsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<AttestationTxnsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<AttestationTxnsOrderBy>>;\n  where?: InputMaybe<AttestationTxnsBoolExp>;\n};\n\n\n/** columns and relationships of \"attestations\" */\nexport type AttestationsMetadataArgs = {\n  path?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** aggregated selection of \"attestations\" */\nexport type AttestationsAggregate = {\n  __typename?: 'AttestationsAggregate';\n  aggregate?: Maybe<AttestationsAggregateFields>;\n  nodes: Array<Attestations>;\n};\n\n/** aggregate fields of \"attestations\" */\nexport type AttestationsAggregateFields = {\n  __typename?: 'AttestationsAggregateFields';\n  avg?: Maybe<AttestationsAvgFields>;\n  count: Scalars['Int']['output'];\n  max?: Maybe<AttestationsMaxFields>;\n  min?: Maybe<AttestationsMinFields>;\n  stddev?: Maybe<AttestationsStddevFields>;\n  stddevPop?: Maybe<AttestationsStddevPopFields>;\n  stddevSamp?: Maybe<AttestationsStddevSampFields>;\n  sum?: Maybe<AttestationsSumFields>;\n  varPop?: Maybe<AttestationsVarPopFields>;\n  varSamp?: Maybe<AttestationsVarSampFields>;\n  variance?: Maybe<AttestationsVarianceFields>;\n};\n\n\n/** aggregate fields of \"attestations\" */\nexport type AttestationsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<AttestationsSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** aggregate avg on columns */\nexport type AttestationsAvgFields = {\n  __typename?: 'AttestationsAvgFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  chainIdsContributed?: Maybe<Scalars['Float']['output']>;\n  fee?: Maybe<Scalars['Float']['output']>;\n  projectsContributed?: Maybe<Scalars['Float']['output']>;\n  roundsContributed?: Maybe<Scalars['Float']['output']>;\n  totalUsdamount?: Maybe<Scalars['Float']['output']>;\n};\n\n/** Boolean expression to filter rows from the table \"attestations\". All fields are combined with a logical 'AND'. */\nexport type AttestationsBoolExp = {\n  _and?: InputMaybe<Array<AttestationsBoolExp>>;\n  _not?: InputMaybe<AttestationsBoolExp>;\n  _or?: InputMaybe<Array<AttestationsBoolExp>>;\n  attestationTxns?: InputMaybe<AttestationTxnsBoolExp>;\n  attestationTxnsAggregate?: InputMaybe<AttestationTxnsAggregateBoolExp>;\n  chainId?: InputMaybe<IntComparisonExp>;\n  chainIdsContributed?: InputMaybe<NumericComparisonExp>;\n  fee?: InputMaybe<NumericComparisonExp>;\n  metadata?: InputMaybe<JsonbComparisonExp>;\n  metadataCid?: InputMaybe<StringComparisonExp>;\n  projectsContributed?: InputMaybe<NumericComparisonExp>;\n  recipient?: InputMaybe<StringComparisonExp>;\n  refUid?: InputMaybe<StringComparisonExp>;\n  roundsContributed?: InputMaybe<NumericComparisonExp>;\n  timestamp?: InputMaybe<TimestamptzComparisonExp>;\n  totalUsdamount?: InputMaybe<NumericComparisonExp>;\n  uid?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type AttestationsMaxFields = {\n  __typename?: 'AttestationsMaxFields';\n  chainId?: Maybe<Scalars['Int']['output']>;\n  chainIdsContributed?: Maybe<Scalars['numeric']['output']>;\n  fee?: Maybe<Scalars['numeric']['output']>;\n  metadataCid?: Maybe<Scalars['String']['output']>;\n  projectsContributed?: Maybe<Scalars['numeric']['output']>;\n  recipient?: Maybe<Scalars['String']['output']>;\n  refUid?: Maybe<Scalars['String']['output']>;\n  roundsContributed?: Maybe<Scalars['numeric']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  totalUsdamount?: Maybe<Scalars['numeric']['output']>;\n  uid?: Maybe<Scalars['String']['output']>;\n};\n\n/** aggregate min on columns */\nexport type AttestationsMinFields = {\n  __typename?: 'AttestationsMinFields';\n  chainId?: Maybe<Scalars['Int']['output']>;\n  chainIdsContributed?: Maybe<Scalars['numeric']['output']>;\n  fee?: Maybe<Scalars['numeric']['output']>;\n  metadataCid?: Maybe<Scalars['String']['output']>;\n  projectsContributed?: Maybe<Scalars['numeric']['output']>;\n  recipient?: Maybe<Scalars['String']['output']>;\n  refUid?: Maybe<Scalars['String']['output']>;\n  roundsContributed?: Maybe<Scalars['numeric']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  totalUsdamount?: Maybe<Scalars['numeric']['output']>;\n  uid?: Maybe<Scalars['String']['output']>;\n};\n\n/** Ordering options when selecting data from \"attestations\". */\nexport type AttestationsOrderBy = {\n  attestationTxnsAggregate?: InputMaybe<AttestationTxnsAggregateOrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  chainIdsContributed?: InputMaybe<OrderBy>;\n  fee?: InputMaybe<OrderBy>;\n  metadata?: InputMaybe<OrderBy>;\n  metadataCid?: InputMaybe<OrderBy>;\n  projectsContributed?: InputMaybe<OrderBy>;\n  recipient?: InputMaybe<OrderBy>;\n  refUid?: InputMaybe<OrderBy>;\n  roundsContributed?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  totalUsdamount?: InputMaybe<OrderBy>;\n  uid?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"attestations\" */\nexport enum AttestationsSelectColumn {\n  /** column name */\n  ChainId = 'chainId',\n  /** column name */\n  ChainIdsContributed = 'chainIdsContributed',\n  /** column name */\n  Fee = 'fee',\n  /** column name */\n  Metadata = 'metadata',\n  /** column name */\n  MetadataCid = 'metadataCid',\n  /** column name */\n  ProjectsContributed = 'projectsContributed',\n  /** column name */\n  Recipient = 'recipient',\n  /** column name */\n  RefUid = 'refUid',\n  /** column name */\n  RoundsContributed = 'roundsContributed',\n  /** column name */\n  Timestamp = 'timestamp',\n  /** column name */\n  TotalUsdamount = 'totalUsdamount',\n  /** column name */\n  Uid = 'uid'\n}\n\n/** aggregate stddev on columns */\nexport type AttestationsStddevFields = {\n  __typename?: 'AttestationsStddevFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  chainIdsContributed?: Maybe<Scalars['Float']['output']>;\n  fee?: Maybe<Scalars['Float']['output']>;\n  projectsContributed?: Maybe<Scalars['Float']['output']>;\n  roundsContributed?: Maybe<Scalars['Float']['output']>;\n  totalUsdamount?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate stddevPop on columns */\nexport type AttestationsStddevPopFields = {\n  __typename?: 'AttestationsStddevPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  chainIdsContributed?: Maybe<Scalars['Float']['output']>;\n  fee?: Maybe<Scalars['Float']['output']>;\n  projectsContributed?: Maybe<Scalars['Float']['output']>;\n  roundsContributed?: Maybe<Scalars['Float']['output']>;\n  totalUsdamount?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate stddevSamp on columns */\nexport type AttestationsStddevSampFields = {\n  __typename?: 'AttestationsStddevSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  chainIdsContributed?: Maybe<Scalars['Float']['output']>;\n  fee?: Maybe<Scalars['Float']['output']>;\n  projectsContributed?: Maybe<Scalars['Float']['output']>;\n  roundsContributed?: Maybe<Scalars['Float']['output']>;\n  totalUsdamount?: Maybe<Scalars['Float']['output']>;\n};\n\n/** Streaming cursor of the table \"attestations\" */\nexport type AttestationsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initialValue: AttestationsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type AttestationsStreamCursorValueInput = {\n  chainId?: InputMaybe<Scalars['Int']['input']>;\n  chainIdsContributed?: InputMaybe<Scalars['numeric']['input']>;\n  fee?: InputMaybe<Scalars['numeric']['input']>;\n  metadata?: InputMaybe<Scalars['jsonb']['input']>;\n  metadataCid?: InputMaybe<Scalars['String']['input']>;\n  projectsContributed?: InputMaybe<Scalars['numeric']['input']>;\n  recipient?: InputMaybe<Scalars['String']['input']>;\n  refUid?: InputMaybe<Scalars['String']['input']>;\n  roundsContributed?: InputMaybe<Scalars['numeric']['input']>;\n  timestamp?: InputMaybe<Scalars['timestamptz']['input']>;\n  totalUsdamount?: InputMaybe<Scalars['numeric']['input']>;\n  uid?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** aggregate sum on columns */\nexport type AttestationsSumFields = {\n  __typename?: 'AttestationsSumFields';\n  chainId?: Maybe<Scalars['Int']['output']>;\n  chainIdsContributed?: Maybe<Scalars['numeric']['output']>;\n  fee?: Maybe<Scalars['numeric']['output']>;\n  projectsContributed?: Maybe<Scalars['numeric']['output']>;\n  roundsContributed?: Maybe<Scalars['numeric']['output']>;\n  totalUsdamount?: Maybe<Scalars['numeric']['output']>;\n};\n\n/** aggregate varPop on columns */\nexport type AttestationsVarPopFields = {\n  __typename?: 'AttestationsVarPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  chainIdsContributed?: Maybe<Scalars['Float']['output']>;\n  fee?: Maybe<Scalars['Float']['output']>;\n  projectsContributed?: Maybe<Scalars['Float']['output']>;\n  roundsContributed?: Maybe<Scalars['Float']['output']>;\n  totalUsdamount?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate varSamp on columns */\nexport type AttestationsVarSampFields = {\n  __typename?: 'AttestationsVarSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  chainIdsContributed?: Maybe<Scalars['Float']['output']>;\n  fee?: Maybe<Scalars['Float']['output']>;\n  projectsContributed?: Maybe<Scalars['Float']['output']>;\n  roundsContributed?: Maybe<Scalars['Float']['output']>;\n  totalUsdamount?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate variance on columns */\nexport type AttestationsVarianceFields = {\n  __typename?: 'AttestationsVarianceFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  chainIdsContributed?: Maybe<Scalars['Float']['output']>;\n  fee?: Maybe<Scalars['Float']['output']>;\n  projectsContributed?: Maybe<Scalars['Float']['output']>;\n  roundsContributed?: Maybe<Scalars['Float']['output']>;\n  totalUsdamount?: Maybe<Scalars['Float']['output']>;\n};\n\n/** Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'. */\nexport type BigintComparisonExp = {\n  _eq?: InputMaybe<Scalars['bigint']['input']>;\n  _gt?: InputMaybe<Scalars['bigint']['input']>;\n  _gte?: InputMaybe<Scalars['bigint']['input']>;\n  _in?: InputMaybe<Array<Scalars['bigint']['input']>>;\n  _isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  _lt?: InputMaybe<Scalars['bigint']['input']>;\n  _lte?: InputMaybe<Scalars['bigint']['input']>;\n  _neq?: InputMaybe<Scalars['bigint']['input']>;\n  _nin?: InputMaybe<Array<Scalars['bigint']['input']>>;\n};\n\n/** ordering argument of a cursor */\nexport enum CursorOrdering {\n  /** ascending ordering of the cursor */\n  Asc = 'ASC',\n  /** descending ordering of the cursor */\n  Desc = 'DESC'\n}\n\n/** columns and relationships of \"donations\" */\nexport type Donations = {\n  __typename?: 'Donations';\n  amount?: Maybe<Scalars['numeric']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['numeric']['output']>;\n  amountInUsd?: Maybe<Scalars['numeric']['output']>;\n  /** An object relationship */\n  application?: Maybe<Applications>;\n  applicationId?: Maybe<Scalars['String']['output']>;\n  /** An array relationship */\n  attestationTransactions: Array<AttestationTxns>;\n  /** An aggregate relationship */\n  attestationTransactionsAggregate: AttestationTxnsAggregate;\n  blockNumber?: Maybe<Scalars['numeric']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  donorAddress?: Maybe<Scalars['String']['output']>;\n  id: Scalars['String']['output'];\n  projectId?: Maybe<Scalars['String']['output']>;\n  recipientAddress?: Maybe<Scalars['String']['output']>;\n  /** An object relationship */\n  round?: Maybe<Rounds>;\n  roundId?: Maybe<Scalars['String']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  tokenAddress?: Maybe<Scalars['String']['output']>;\n  transactionHash?: Maybe<Scalars['String']['output']>;\n};\n\n\n/** columns and relationships of \"donations\" */\nexport type DonationsAttestationTransactionsArgs = {\n  distinctOn?: InputMaybe<Array<AttestationTxnsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<AttestationTxnsOrderBy>>;\n  where?: InputMaybe<AttestationTxnsBoolExp>;\n};\n\n\n/** columns and relationships of \"donations\" */\nexport type DonationsAttestationTransactionsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<AttestationTxnsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<AttestationTxnsOrderBy>>;\n  where?: InputMaybe<AttestationTxnsBoolExp>;\n};\n\n/** aggregated selection of \"donations\" */\nexport type DonationsAggregate = {\n  __typename?: 'DonationsAggregate';\n  aggregate?: Maybe<DonationsAggregateFields>;\n  nodes: Array<Donations>;\n};\n\nexport type DonationsAggregateBoolExp = {\n  count?: InputMaybe<DonationsAggregateBoolExpCount>;\n};\n\n/** aggregate fields of \"donations\" */\nexport type DonationsAggregateFields = {\n  __typename?: 'DonationsAggregateFields';\n  avg?: Maybe<DonationsAvgFields>;\n  count: Scalars['Int']['output'];\n  max?: Maybe<DonationsMaxFields>;\n  min?: Maybe<DonationsMinFields>;\n  stddev?: Maybe<DonationsStddevFields>;\n  stddevPop?: Maybe<DonationsStddevPopFields>;\n  stddevSamp?: Maybe<DonationsStddevSampFields>;\n  sum?: Maybe<DonationsSumFields>;\n  varPop?: Maybe<DonationsVarPopFields>;\n  varSamp?: Maybe<DonationsVarSampFields>;\n  variance?: Maybe<DonationsVarianceFields>;\n};\n\n\n/** aggregate fields of \"donations\" */\nexport type DonationsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<DonationsSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** order by aggregate values of table \"donations\" */\nexport type DonationsAggregateOrderBy = {\n  avg?: InputMaybe<DonationsAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<DonationsMaxOrderBy>;\n  min?: InputMaybe<DonationsMinOrderBy>;\n  stddev?: InputMaybe<DonationsStddevOrderBy>;\n  stddevPop?: InputMaybe<DonationsStddevPopOrderBy>;\n  stddevSamp?: InputMaybe<DonationsStddevSampOrderBy>;\n  sum?: InputMaybe<DonationsSumOrderBy>;\n  varPop?: InputMaybe<DonationsVarPopOrderBy>;\n  varSamp?: InputMaybe<DonationsVarSampOrderBy>;\n  variance?: InputMaybe<DonationsVarianceOrderBy>;\n};\n\n/** aggregate avg on columns */\nexport type DonationsAvgFields = {\n  __typename?: 'DonationsAvgFields';\n  amount?: Maybe<Scalars['Float']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['Float']['output']>;\n  amountInUsd?: Maybe<Scalars['Float']['output']>;\n  blockNumber?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by avg() on columns of table \"donations\" */\nexport type DonationsAvgOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  blockNumber?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"donations\". All fields are combined with a logical 'AND'. */\nexport type DonationsBoolExp = {\n  _and?: InputMaybe<Array<DonationsBoolExp>>;\n  _not?: InputMaybe<DonationsBoolExp>;\n  _or?: InputMaybe<Array<DonationsBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  amountInRoundMatchToken?: InputMaybe<NumericComparisonExp>;\n  amountInUsd?: InputMaybe<NumericComparisonExp>;\n  application?: InputMaybe<ApplicationsBoolExp>;\n  applicationId?: InputMaybe<StringComparisonExp>;\n  attestationTransactions?: InputMaybe<AttestationTxnsBoolExp>;\n  attestationTransactionsAggregate?: InputMaybe<AttestationTxnsAggregateBoolExp>;\n  blockNumber?: InputMaybe<NumericComparisonExp>;\n  chainId?: InputMaybe<IntComparisonExp>;\n  donorAddress?: InputMaybe<StringComparisonExp>;\n  id?: InputMaybe<StringComparisonExp>;\n  projectId?: InputMaybe<StringComparisonExp>;\n  recipientAddress?: InputMaybe<StringComparisonExp>;\n  round?: InputMaybe<RoundsBoolExp>;\n  roundId?: InputMaybe<StringComparisonExp>;\n  timestamp?: InputMaybe<TimestamptzComparisonExp>;\n  tokenAddress?: InputMaybe<StringComparisonExp>;\n  transactionHash?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type DonationsMaxFields = {\n  __typename?: 'DonationsMaxFields';\n  amount?: Maybe<Scalars['numeric']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['numeric']['output']>;\n  amountInUsd?: Maybe<Scalars['numeric']['output']>;\n  applicationId?: Maybe<Scalars['String']['output']>;\n  blockNumber?: Maybe<Scalars['numeric']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  donorAddress?: Maybe<Scalars['String']['output']>;\n  id?: Maybe<Scalars['String']['output']>;\n  projectId?: Maybe<Scalars['String']['output']>;\n  recipientAddress?: Maybe<Scalars['String']['output']>;\n  roundId?: Maybe<Scalars['String']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  tokenAddress?: Maybe<Scalars['String']['output']>;\n  transactionHash?: Maybe<Scalars['String']['output']>;\n};\n\n/** order by max() on columns of table \"donations\" */\nexport type DonationsMaxOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  applicationId?: InputMaybe<OrderBy>;\n  blockNumber?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  donorAddress?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  projectId?: InputMaybe<OrderBy>;\n  recipientAddress?: InputMaybe<OrderBy>;\n  roundId?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  tokenAddress?: InputMaybe<OrderBy>;\n  transactionHash?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type DonationsMinFields = {\n  __typename?: 'DonationsMinFields';\n  amount?: Maybe<Scalars['numeric']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['numeric']['output']>;\n  amountInUsd?: Maybe<Scalars['numeric']['output']>;\n  applicationId?: Maybe<Scalars['String']['output']>;\n  blockNumber?: Maybe<Scalars['numeric']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  donorAddress?: Maybe<Scalars['String']['output']>;\n  id?: Maybe<Scalars['String']['output']>;\n  projectId?: Maybe<Scalars['String']['output']>;\n  recipientAddress?: Maybe<Scalars['String']['output']>;\n  roundId?: Maybe<Scalars['String']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  tokenAddress?: Maybe<Scalars['String']['output']>;\n  transactionHash?: Maybe<Scalars['String']['output']>;\n};\n\n/** order by min() on columns of table \"donations\" */\nexport type DonationsMinOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  applicationId?: InputMaybe<OrderBy>;\n  blockNumber?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  donorAddress?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  projectId?: InputMaybe<OrderBy>;\n  recipientAddress?: InputMaybe<OrderBy>;\n  roundId?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  tokenAddress?: InputMaybe<OrderBy>;\n  transactionHash?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"donations\". */\nexport type DonationsOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  application?: InputMaybe<ApplicationsOrderBy>;\n  applicationId?: InputMaybe<OrderBy>;\n  attestationTransactionsAggregate?: InputMaybe<AttestationTxnsAggregateOrderBy>;\n  blockNumber?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  donorAddress?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  projectId?: InputMaybe<OrderBy>;\n  recipientAddress?: InputMaybe<OrderBy>;\n  round?: InputMaybe<RoundsOrderBy>;\n  roundId?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  tokenAddress?: InputMaybe<OrderBy>;\n  transactionHash?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"donations\" */\nexport enum DonationsSelectColumn {\n  /** column name */\n  Amount = 'amount',\n  /** column name */\n  AmountInRoundMatchToken = 'amountInRoundMatchToken',\n  /** column name */\n  AmountInUsd = 'amountInUsd',\n  /** column name */\n  ApplicationId = 'applicationId',\n  /** column name */\n  BlockNumber = 'blockNumber',\n  /** column name */\n  ChainId = 'chainId',\n  /** column name */\n  DonorAddress = 'donorAddress',\n  /** column name */\n  Id = 'id',\n  /** column name */\n  ProjectId = 'projectId',\n  /** column name */\n  RecipientAddress = 'recipientAddress',\n  /** column name */\n  RoundId = 'roundId',\n  /** column name */\n  Timestamp = 'timestamp',\n  /** column name */\n  TokenAddress = 'tokenAddress',\n  /** column name */\n  TransactionHash = 'transactionHash'\n}\n\n/** aggregate stddev on columns */\nexport type DonationsStddevFields = {\n  __typename?: 'DonationsStddevFields';\n  amount?: Maybe<Scalars['Float']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['Float']['output']>;\n  amountInUsd?: Maybe<Scalars['Float']['output']>;\n  blockNumber?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddev() on columns of table \"donations\" */\nexport type DonationsStddevOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  blockNumber?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevPop on columns */\nexport type DonationsStddevPopFields = {\n  __typename?: 'DonationsStddevPopFields';\n  amount?: Maybe<Scalars['Float']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['Float']['output']>;\n  amountInUsd?: Maybe<Scalars['Float']['output']>;\n  blockNumber?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevPop() on columns of table \"donations\" */\nexport type DonationsStddevPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  blockNumber?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevSamp on columns */\nexport type DonationsStddevSampFields = {\n  __typename?: 'DonationsStddevSampFields';\n  amount?: Maybe<Scalars['Float']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['Float']['output']>;\n  amountInUsd?: Maybe<Scalars['Float']['output']>;\n  blockNumber?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevSamp() on columns of table \"donations\" */\nexport type DonationsStddevSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  blockNumber?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"donations\" */\nexport type DonationsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initialValue: DonationsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type DonationsStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars['numeric']['input']>;\n  amountInRoundMatchToken?: InputMaybe<Scalars['numeric']['input']>;\n  amountInUsd?: InputMaybe<Scalars['numeric']['input']>;\n  applicationId?: InputMaybe<Scalars['String']['input']>;\n  blockNumber?: InputMaybe<Scalars['numeric']['input']>;\n  chainId?: InputMaybe<Scalars['Int']['input']>;\n  donorAddress?: InputMaybe<Scalars['String']['input']>;\n  id?: InputMaybe<Scalars['String']['input']>;\n  projectId?: InputMaybe<Scalars['String']['input']>;\n  recipientAddress?: InputMaybe<Scalars['String']['input']>;\n  roundId?: InputMaybe<Scalars['String']['input']>;\n  timestamp?: InputMaybe<Scalars['timestamptz']['input']>;\n  tokenAddress?: InputMaybe<Scalars['String']['input']>;\n  transactionHash?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** aggregate sum on columns */\nexport type DonationsSumFields = {\n  __typename?: 'DonationsSumFields';\n  amount?: Maybe<Scalars['numeric']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['numeric']['output']>;\n  amountInUsd?: Maybe<Scalars['numeric']['output']>;\n  blockNumber?: Maybe<Scalars['numeric']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n};\n\n/** order by sum() on columns of table \"donations\" */\nexport type DonationsSumOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  blockNumber?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varPop on columns */\nexport type DonationsVarPopFields = {\n  __typename?: 'DonationsVarPopFields';\n  amount?: Maybe<Scalars['Float']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['Float']['output']>;\n  amountInUsd?: Maybe<Scalars['Float']['output']>;\n  blockNumber?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varPop() on columns of table \"donations\" */\nexport type DonationsVarPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  blockNumber?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varSamp on columns */\nexport type DonationsVarSampFields = {\n  __typename?: 'DonationsVarSampFields';\n  amount?: Maybe<Scalars['Float']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['Float']['output']>;\n  amountInUsd?: Maybe<Scalars['Float']['output']>;\n  blockNumber?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varSamp() on columns of table \"donations\" */\nexport type DonationsVarSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  blockNumber?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type DonationsVarianceFields = {\n  __typename?: 'DonationsVarianceFields';\n  amount?: Maybe<Scalars['Float']['output']>;\n  amountInRoundMatchToken?: Maybe<Scalars['Float']['output']>;\n  amountInUsd?: Maybe<Scalars['Float']['output']>;\n  blockNumber?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by variance() on columns of table \"donations\" */\nexport type DonationsVarianceOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amountInRoundMatchToken?: InputMaybe<OrderBy>;\n  amountInUsd?: InputMaybe<OrderBy>;\n  blockNumber?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"events_registry\" */\nexport type EventsRegistry = {\n  __typename?: 'EventsRegistry';\n  blockNumber?: Maybe<Scalars['Int']['output']>;\n  blockTimestamp?: Maybe<Scalars['bigint']['output']>;\n  chainId: Scalars['Int']['output'];\n  logIndex?: Maybe<Scalars['Int']['output']>;\n  rawEvent?: Maybe<Scalars['jsonb']['output']>;\n};\n\n\n/** columns and relationships of \"events_registry\" */\nexport type EventsRegistryRawEventArgs = {\n  path?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** aggregated selection of \"events_registry\" */\nexport type EventsRegistryAggregate = {\n  __typename?: 'EventsRegistryAggregate';\n  aggregate?: Maybe<EventsRegistryAggregateFields>;\n  nodes: Array<EventsRegistry>;\n};\n\n/** aggregate fields of \"events_registry\" */\nexport type EventsRegistryAggregateFields = {\n  __typename?: 'EventsRegistryAggregateFields';\n  avg?: Maybe<EventsRegistryAvgFields>;\n  count: Scalars['Int']['output'];\n  max?: Maybe<EventsRegistryMaxFields>;\n  min?: Maybe<EventsRegistryMinFields>;\n  stddev?: Maybe<EventsRegistryStddevFields>;\n  stddevPop?: Maybe<EventsRegistryStddevPopFields>;\n  stddevSamp?: Maybe<EventsRegistryStddevSampFields>;\n  sum?: Maybe<EventsRegistrySumFields>;\n  varPop?: Maybe<EventsRegistryVarPopFields>;\n  varSamp?: Maybe<EventsRegistryVarSampFields>;\n  variance?: Maybe<EventsRegistryVarianceFields>;\n};\n\n\n/** aggregate fields of \"events_registry\" */\nexport type EventsRegistryAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<EventsRegistrySelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** aggregate avg on columns */\nexport type EventsRegistryAvgFields = {\n  __typename?: 'EventsRegistryAvgFields';\n  blockNumber?: Maybe<Scalars['Float']['output']>;\n  blockTimestamp?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n  logIndex?: Maybe<Scalars['Float']['output']>;\n};\n\n/** Boolean expression to filter rows from the table \"events_registry\". All fields are combined with a logical 'AND'. */\nexport type EventsRegistryBoolExp = {\n  _and?: InputMaybe<Array<EventsRegistryBoolExp>>;\n  _not?: InputMaybe<EventsRegistryBoolExp>;\n  _or?: InputMaybe<Array<EventsRegistryBoolExp>>;\n  blockNumber?: InputMaybe<IntComparisonExp>;\n  blockTimestamp?: InputMaybe<BigintComparisonExp>;\n  chainId?: InputMaybe<IntComparisonExp>;\n  logIndex?: InputMaybe<IntComparisonExp>;\n  rawEvent?: InputMaybe<JsonbComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type EventsRegistryMaxFields = {\n  __typename?: 'EventsRegistryMaxFields';\n  blockNumber?: Maybe<Scalars['Int']['output']>;\n  blockTimestamp?: Maybe<Scalars['bigint']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  logIndex?: Maybe<Scalars['Int']['output']>;\n};\n\n/** aggregate min on columns */\nexport type EventsRegistryMinFields = {\n  __typename?: 'EventsRegistryMinFields';\n  blockNumber?: Maybe<Scalars['Int']['output']>;\n  blockTimestamp?: Maybe<Scalars['bigint']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  logIndex?: Maybe<Scalars['Int']['output']>;\n};\n\n/** Ordering options when selecting data from \"events_registry\". */\nexport type EventsRegistryOrderBy = {\n  blockNumber?: InputMaybe<OrderBy>;\n  blockTimestamp?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  logIndex?: InputMaybe<OrderBy>;\n  rawEvent?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"events_registry\" */\nexport enum EventsRegistrySelectColumn {\n  /** column name */\n  BlockNumber = 'blockNumber',\n  /** column name */\n  BlockTimestamp = 'blockTimestamp',\n  /** column name */\n  ChainId = 'chainId',\n  /** column name */\n  LogIndex = 'logIndex',\n  /** column name */\n  RawEvent = 'rawEvent'\n}\n\n/** aggregate stddev on columns */\nexport type EventsRegistryStddevFields = {\n  __typename?: 'EventsRegistryStddevFields';\n  blockNumber?: Maybe<Scalars['Float']['output']>;\n  blockTimestamp?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n  logIndex?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate stddevPop on columns */\nexport type EventsRegistryStddevPopFields = {\n  __typename?: 'EventsRegistryStddevPopFields';\n  blockNumber?: Maybe<Scalars['Float']['output']>;\n  blockTimestamp?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n  logIndex?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate stddevSamp on columns */\nexport type EventsRegistryStddevSampFields = {\n  __typename?: 'EventsRegistryStddevSampFields';\n  blockNumber?: Maybe<Scalars['Float']['output']>;\n  blockTimestamp?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n  logIndex?: Maybe<Scalars['Float']['output']>;\n};\n\n/** Streaming cursor of the table \"events_registry\" */\nexport type EventsRegistryStreamCursorInput = {\n  /** Stream column input with initial value */\n  initialValue: EventsRegistryStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type EventsRegistryStreamCursorValueInput = {\n  blockNumber?: InputMaybe<Scalars['Int']['input']>;\n  blockTimestamp?: InputMaybe<Scalars['bigint']['input']>;\n  chainId?: InputMaybe<Scalars['Int']['input']>;\n  logIndex?: InputMaybe<Scalars['Int']['input']>;\n  rawEvent?: InputMaybe<Scalars['jsonb']['input']>;\n};\n\n/** aggregate sum on columns */\nexport type EventsRegistrySumFields = {\n  __typename?: 'EventsRegistrySumFields';\n  blockNumber?: Maybe<Scalars['Int']['output']>;\n  blockTimestamp?: Maybe<Scalars['bigint']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  logIndex?: Maybe<Scalars['Int']['output']>;\n};\n\n/** aggregate varPop on columns */\nexport type EventsRegistryVarPopFields = {\n  __typename?: 'EventsRegistryVarPopFields';\n  blockNumber?: Maybe<Scalars['Float']['output']>;\n  blockTimestamp?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n  logIndex?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate varSamp on columns */\nexport type EventsRegistryVarSampFields = {\n  __typename?: 'EventsRegistryVarSampFields';\n  blockNumber?: Maybe<Scalars['Float']['output']>;\n  blockTimestamp?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n  logIndex?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate variance on columns */\nexport type EventsRegistryVarianceFields = {\n  __typename?: 'EventsRegistryVarianceFields';\n  blockNumber?: Maybe<Scalars['Float']['output']>;\n  blockTimestamp?: Maybe<Scalars['Float']['output']>;\n  chainId?: Maybe<Scalars['Float']['output']>;\n  logIndex?: Maybe<Scalars['Float']['output']>;\n};\n\n/** Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'. */\nexport type IntComparisonExp = {\n  _eq?: InputMaybe<Scalars['Int']['input']>;\n  _gt?: InputMaybe<Scalars['Int']['input']>;\n  _gte?: InputMaybe<Scalars['Int']['input']>;\n  _in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  _isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  _lt?: InputMaybe<Scalars['Int']['input']>;\n  _lte?: InputMaybe<Scalars['Int']['input']>;\n  _neq?: InputMaybe<Scalars['Int']['input']>;\n  _nin?: InputMaybe<Array<Scalars['Int']['input']>>;\n};\n\nexport type JsonbCastExp = {\n  String?: InputMaybe<StringComparisonExp>;\n};\n\n/** Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'. */\nexport type JsonbComparisonExp = {\n  _cast?: InputMaybe<JsonbCastExp>;\n  /** is the column contained in the given json value */\n  _containedIn?: InputMaybe<Scalars['jsonb']['input']>;\n  /** does the column contain the given json value at the top level */\n  _contains?: InputMaybe<Scalars['jsonb']['input']>;\n  _eq?: InputMaybe<Scalars['jsonb']['input']>;\n  _gt?: InputMaybe<Scalars['jsonb']['input']>;\n  _gte?: InputMaybe<Scalars['jsonb']['input']>;\n  /** does the string exist as a top-level key in the column */\n  _hasKey?: InputMaybe<Scalars['String']['input']>;\n  /** do all of these strings exist as top-level keys in the column */\n  _hasKeysAll?: InputMaybe<Array<Scalars['String']['input']>>;\n  /** do any of these strings exist as top-level keys in the column */\n  _hasKeysAny?: InputMaybe<Array<Scalars['String']['input']>>;\n  _in?: InputMaybe<Array<Scalars['jsonb']['input']>>;\n  _isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  _lt?: InputMaybe<Scalars['jsonb']['input']>;\n  _lte?: InputMaybe<Scalars['jsonb']['input']>;\n  _neq?: InputMaybe<Scalars['jsonb']['input']>;\n  _nin?: InputMaybe<Array<Scalars['jsonb']['input']>>;\n};\n\n/** columns and relationships of \"legacy_projects\" */\nexport type LegacyProjects = {\n  __typename?: 'LegacyProjects';\n  id: Scalars['Int']['output'];\n  v1ChainId?: Maybe<Scalars['Int']['output']>;\n  v1ProjectId?: Maybe<Scalars['String']['output']>;\n  v2ProjectId?: Maybe<Scalars['String']['output']>;\n};\n\n/** aggregated selection of \"legacy_projects\" */\nexport type LegacyProjectsAggregate = {\n  __typename?: 'LegacyProjectsAggregate';\n  aggregate?: Maybe<LegacyProjectsAggregateFields>;\n  nodes: Array<LegacyProjects>;\n};\n\n/** aggregate fields of \"legacy_projects\" */\nexport type LegacyProjectsAggregateFields = {\n  __typename?: 'LegacyProjectsAggregateFields';\n  avg?: Maybe<LegacyProjectsAvgFields>;\n  count: Scalars['Int']['output'];\n  max?: Maybe<LegacyProjectsMaxFields>;\n  min?: Maybe<LegacyProjectsMinFields>;\n  stddev?: Maybe<LegacyProjectsStddevFields>;\n  stddevPop?: Maybe<LegacyProjectsStddevPopFields>;\n  stddevSamp?: Maybe<LegacyProjectsStddevSampFields>;\n  sum?: Maybe<LegacyProjectsSumFields>;\n  varPop?: Maybe<LegacyProjectsVarPopFields>;\n  varSamp?: Maybe<LegacyProjectsVarSampFields>;\n  variance?: Maybe<LegacyProjectsVarianceFields>;\n};\n\n\n/** aggregate fields of \"legacy_projects\" */\nexport type LegacyProjectsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<LegacyProjectsSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** aggregate avg on columns */\nexport type LegacyProjectsAvgFields = {\n  __typename?: 'LegacyProjectsAvgFields';\n  id?: Maybe<Scalars['Float']['output']>;\n  v1ChainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** Boolean expression to filter rows from the table \"legacy_projects\". All fields are combined with a logical 'AND'. */\nexport type LegacyProjectsBoolExp = {\n  _and?: InputMaybe<Array<LegacyProjectsBoolExp>>;\n  _not?: InputMaybe<LegacyProjectsBoolExp>;\n  _or?: InputMaybe<Array<LegacyProjectsBoolExp>>;\n  id?: InputMaybe<IntComparisonExp>;\n  v1ChainId?: InputMaybe<IntComparisonExp>;\n  v1ProjectId?: InputMaybe<StringComparisonExp>;\n  v2ProjectId?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type LegacyProjectsMaxFields = {\n  __typename?: 'LegacyProjectsMaxFields';\n  id?: Maybe<Scalars['Int']['output']>;\n  v1ChainId?: Maybe<Scalars['Int']['output']>;\n  v1ProjectId?: Maybe<Scalars['String']['output']>;\n  v2ProjectId?: Maybe<Scalars['String']['output']>;\n};\n\n/** aggregate min on columns */\nexport type LegacyProjectsMinFields = {\n  __typename?: 'LegacyProjectsMinFields';\n  id?: Maybe<Scalars['Int']['output']>;\n  v1ChainId?: Maybe<Scalars['Int']['output']>;\n  v1ProjectId?: Maybe<Scalars['String']['output']>;\n  v2ProjectId?: Maybe<Scalars['String']['output']>;\n};\n\n/** Ordering options when selecting data from \"legacy_projects\". */\nexport type LegacyProjectsOrderBy = {\n  id?: InputMaybe<OrderBy>;\n  v1ChainId?: InputMaybe<OrderBy>;\n  v1ProjectId?: InputMaybe<OrderBy>;\n  v2ProjectId?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"legacy_projects\" */\nexport enum LegacyProjectsSelectColumn {\n  /** column name */\n  Id = 'id',\n  /** column name */\n  V1ChainId = 'v1ChainId',\n  /** column name */\n  V1ProjectId = 'v1ProjectId',\n  /** column name */\n  V2ProjectId = 'v2ProjectId'\n}\n\n/** aggregate stddev on columns */\nexport type LegacyProjectsStddevFields = {\n  __typename?: 'LegacyProjectsStddevFields';\n  id?: Maybe<Scalars['Float']['output']>;\n  v1ChainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate stddevPop on columns */\nexport type LegacyProjectsStddevPopFields = {\n  __typename?: 'LegacyProjectsStddevPopFields';\n  id?: Maybe<Scalars['Float']['output']>;\n  v1ChainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate stddevSamp on columns */\nexport type LegacyProjectsStddevSampFields = {\n  __typename?: 'LegacyProjectsStddevSampFields';\n  id?: Maybe<Scalars['Float']['output']>;\n  v1ChainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** Streaming cursor of the table \"legacy_projects\" */\nexport type LegacyProjectsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initialValue: LegacyProjectsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type LegacyProjectsStreamCursorValueInput = {\n  id?: InputMaybe<Scalars['Int']['input']>;\n  v1ChainId?: InputMaybe<Scalars['Int']['input']>;\n  v1ProjectId?: InputMaybe<Scalars['String']['input']>;\n  v2ProjectId?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** aggregate sum on columns */\nexport type LegacyProjectsSumFields = {\n  __typename?: 'LegacyProjectsSumFields';\n  id?: Maybe<Scalars['Int']['output']>;\n  v1ChainId?: Maybe<Scalars['Int']['output']>;\n};\n\n/** aggregate varPop on columns */\nexport type LegacyProjectsVarPopFields = {\n  __typename?: 'LegacyProjectsVarPopFields';\n  id?: Maybe<Scalars['Float']['output']>;\n  v1ChainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate varSamp on columns */\nexport type LegacyProjectsVarSampFields = {\n  __typename?: 'LegacyProjectsVarSampFields';\n  id?: Maybe<Scalars['Float']['output']>;\n  v1ChainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate variance on columns */\nexport type LegacyProjectsVarianceFields = {\n  __typename?: 'LegacyProjectsVarianceFields';\n  id?: Maybe<Scalars['Float']['output']>;\n  v1ChainId?: Maybe<Scalars['Float']['output']>;\n};\n\n/** Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'. */\nexport type NumericComparisonExp = {\n  _eq?: InputMaybe<Scalars['numeric']['input']>;\n  _gt?: InputMaybe<Scalars['numeric']['input']>;\n  _gte?: InputMaybe<Scalars['numeric']['input']>;\n  _in?: InputMaybe<Array<Scalars['numeric']['input']>>;\n  _isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  _lt?: InputMaybe<Scalars['numeric']['input']>;\n  _lte?: InputMaybe<Scalars['numeric']['input']>;\n  _neq?: InputMaybe<Scalars['numeric']['input']>;\n  _nin?: InputMaybe<Array<Scalars['numeric']['input']>>;\n};\n\n/** column ordering options */\nexport enum OrderBy {\n  /** in ascending order, nulls last */\n  Asc = 'ASC',\n  /** in ascending order, nulls first */\n  AscNullsFirst = 'ASC_NULLS_FIRST',\n  /** in ascending order, nulls last */\n  AscNullsLast = 'ASC_NULLS_LAST',\n  /** in descending order, nulls first */\n  Desc = 'DESC',\n  /** in descending order, nulls first */\n  DescNullsFirst = 'DESC_NULLS_FIRST',\n  /** in descending order, nulls last */\n  DescNullsLast = 'DESC_NULLS_LAST'\n}\n\n/** columns and relationships of \"pending_project_roles\" */\nexport type PendingProjectRoles = {\n  __typename?: 'PendingProjectRoles';\n  address?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  id: Scalars['Int']['output'];\n  role?: Maybe<Scalars['String']['output']>;\n};\n\n/** aggregated selection of \"pending_project_roles\" */\nexport type PendingProjectRolesAggregate = {\n  __typename?: 'PendingProjectRolesAggregate';\n  aggregate?: Maybe<PendingProjectRolesAggregateFields>;\n  nodes: Array<PendingProjectRoles>;\n};\n\n/** aggregate fields of \"pending_project_roles\" */\nexport type PendingProjectRolesAggregateFields = {\n  __typename?: 'PendingProjectRolesAggregateFields';\n  avg?: Maybe<PendingProjectRolesAvgFields>;\n  count: Scalars['Int']['output'];\n  max?: Maybe<PendingProjectRolesMaxFields>;\n  min?: Maybe<PendingProjectRolesMinFields>;\n  stddev?: Maybe<PendingProjectRolesStddevFields>;\n  stddevPop?: Maybe<PendingProjectRolesStddevPopFields>;\n  stddevSamp?: Maybe<PendingProjectRolesStddevSampFields>;\n  sum?: Maybe<PendingProjectRolesSumFields>;\n  varPop?: Maybe<PendingProjectRolesVarPopFields>;\n  varSamp?: Maybe<PendingProjectRolesVarSampFields>;\n  variance?: Maybe<PendingProjectRolesVarianceFields>;\n};\n\n\n/** aggregate fields of \"pending_project_roles\" */\nexport type PendingProjectRolesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<PendingProjectRolesSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** aggregate avg on columns */\nexport type PendingProjectRolesAvgFields = {\n  __typename?: 'PendingProjectRolesAvgFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** Boolean expression to filter rows from the table \"pending_project_roles\". All fields are combined with a logical 'AND'. */\nexport type PendingProjectRolesBoolExp = {\n  _and?: InputMaybe<Array<PendingProjectRolesBoolExp>>;\n  _not?: InputMaybe<PendingProjectRolesBoolExp>;\n  _or?: InputMaybe<Array<PendingProjectRolesBoolExp>>;\n  address?: InputMaybe<StringComparisonExp>;\n  chainId?: InputMaybe<IntComparisonExp>;\n  createdAtBlock?: InputMaybe<NumericComparisonExp>;\n  id?: InputMaybe<IntComparisonExp>;\n  role?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type PendingProjectRolesMaxFields = {\n  __typename?: 'PendingProjectRolesMaxFields';\n  address?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  id?: Maybe<Scalars['Int']['output']>;\n  role?: Maybe<Scalars['String']['output']>;\n};\n\n/** aggregate min on columns */\nexport type PendingProjectRolesMinFields = {\n  __typename?: 'PendingProjectRolesMinFields';\n  address?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  id?: Maybe<Scalars['Int']['output']>;\n  role?: Maybe<Scalars['String']['output']>;\n};\n\n/** Ordering options when selecting data from \"pending_project_roles\". */\nexport type PendingProjectRolesOrderBy = {\n  address?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  role?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"pending_project_roles\" */\nexport enum PendingProjectRolesSelectColumn {\n  /** column name */\n  Address = 'address',\n  /** column name */\n  ChainId = 'chainId',\n  /** column name */\n  CreatedAtBlock = 'createdAtBlock',\n  /** column name */\n  Id = 'id',\n  /** column name */\n  Role = 'role'\n}\n\n/** aggregate stddev on columns */\nexport type PendingProjectRolesStddevFields = {\n  __typename?: 'PendingProjectRolesStddevFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate stddevPop on columns */\nexport type PendingProjectRolesStddevPopFields = {\n  __typename?: 'PendingProjectRolesStddevPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate stddevSamp on columns */\nexport type PendingProjectRolesStddevSampFields = {\n  __typename?: 'PendingProjectRolesStddevSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** Streaming cursor of the table \"pending_project_roles\" */\nexport type PendingProjectRolesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initialValue: PendingProjectRolesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type PendingProjectRolesStreamCursorValueInput = {\n  address?: InputMaybe<Scalars['String']['input']>;\n  chainId?: InputMaybe<Scalars['Int']['input']>;\n  createdAtBlock?: InputMaybe<Scalars['numeric']['input']>;\n  id?: InputMaybe<Scalars['Int']['input']>;\n  role?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** aggregate sum on columns */\nexport type PendingProjectRolesSumFields = {\n  __typename?: 'PendingProjectRolesSumFields';\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  id?: Maybe<Scalars['Int']['output']>;\n};\n\n/** aggregate varPop on columns */\nexport type PendingProjectRolesVarPopFields = {\n  __typename?: 'PendingProjectRolesVarPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate varSamp on columns */\nexport type PendingProjectRolesVarSampFields = {\n  __typename?: 'PendingProjectRolesVarSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate variance on columns */\nexport type PendingProjectRolesVarianceFields = {\n  __typename?: 'PendingProjectRolesVarianceFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** columns and relationships of \"pending_round_roles\" */\nexport type PendingRoundRoles = {\n  __typename?: 'PendingRoundRoles';\n  address?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  id: Scalars['Int']['output'];\n  role?: Maybe<Scalars['String']['output']>;\n};\n\n/** aggregated selection of \"pending_round_roles\" */\nexport type PendingRoundRolesAggregate = {\n  __typename?: 'PendingRoundRolesAggregate';\n  aggregate?: Maybe<PendingRoundRolesAggregateFields>;\n  nodes: Array<PendingRoundRoles>;\n};\n\n/** aggregate fields of \"pending_round_roles\" */\nexport type PendingRoundRolesAggregateFields = {\n  __typename?: 'PendingRoundRolesAggregateFields';\n  avg?: Maybe<PendingRoundRolesAvgFields>;\n  count: Scalars['Int']['output'];\n  max?: Maybe<PendingRoundRolesMaxFields>;\n  min?: Maybe<PendingRoundRolesMinFields>;\n  stddev?: Maybe<PendingRoundRolesStddevFields>;\n  stddevPop?: Maybe<PendingRoundRolesStddevPopFields>;\n  stddevSamp?: Maybe<PendingRoundRolesStddevSampFields>;\n  sum?: Maybe<PendingRoundRolesSumFields>;\n  varPop?: Maybe<PendingRoundRolesVarPopFields>;\n  varSamp?: Maybe<PendingRoundRolesVarSampFields>;\n  variance?: Maybe<PendingRoundRolesVarianceFields>;\n};\n\n\n/** aggregate fields of \"pending_round_roles\" */\nexport type PendingRoundRolesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<PendingRoundRolesSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** aggregate avg on columns */\nexport type PendingRoundRolesAvgFields = {\n  __typename?: 'PendingRoundRolesAvgFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** Boolean expression to filter rows from the table \"pending_round_roles\". All fields are combined with a logical 'AND'. */\nexport type PendingRoundRolesBoolExp = {\n  _and?: InputMaybe<Array<PendingRoundRolesBoolExp>>;\n  _not?: InputMaybe<PendingRoundRolesBoolExp>;\n  _or?: InputMaybe<Array<PendingRoundRolesBoolExp>>;\n  address?: InputMaybe<StringComparisonExp>;\n  chainId?: InputMaybe<IntComparisonExp>;\n  createdAtBlock?: InputMaybe<NumericComparisonExp>;\n  id?: InputMaybe<IntComparisonExp>;\n  role?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type PendingRoundRolesMaxFields = {\n  __typename?: 'PendingRoundRolesMaxFields';\n  address?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  id?: Maybe<Scalars['Int']['output']>;\n  role?: Maybe<Scalars['String']['output']>;\n};\n\n/** aggregate min on columns */\nexport type PendingRoundRolesMinFields = {\n  __typename?: 'PendingRoundRolesMinFields';\n  address?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  id?: Maybe<Scalars['Int']['output']>;\n  role?: Maybe<Scalars['String']['output']>;\n};\n\n/** Ordering options when selecting data from \"pending_round_roles\". */\nexport type PendingRoundRolesOrderBy = {\n  address?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  role?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"pending_round_roles\" */\nexport enum PendingRoundRolesSelectColumn {\n  /** column name */\n  Address = 'address',\n  /** column name */\n  ChainId = 'chainId',\n  /** column name */\n  CreatedAtBlock = 'createdAtBlock',\n  /** column name */\n  Id = 'id',\n  /** column name */\n  Role = 'role'\n}\n\n/** aggregate stddev on columns */\nexport type PendingRoundRolesStddevFields = {\n  __typename?: 'PendingRoundRolesStddevFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate stddevPop on columns */\nexport type PendingRoundRolesStddevPopFields = {\n  __typename?: 'PendingRoundRolesStddevPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate stddevSamp on columns */\nexport type PendingRoundRolesStddevSampFields = {\n  __typename?: 'PendingRoundRolesStddevSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** Streaming cursor of the table \"pending_round_roles\" */\nexport type PendingRoundRolesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initialValue: PendingRoundRolesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type PendingRoundRolesStreamCursorValueInput = {\n  address?: InputMaybe<Scalars['String']['input']>;\n  chainId?: InputMaybe<Scalars['Int']['input']>;\n  createdAtBlock?: InputMaybe<Scalars['numeric']['input']>;\n  id?: InputMaybe<Scalars['Int']['input']>;\n  role?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** aggregate sum on columns */\nexport type PendingRoundRolesSumFields = {\n  __typename?: 'PendingRoundRolesSumFields';\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  id?: Maybe<Scalars['Int']['output']>;\n};\n\n/** aggregate varPop on columns */\nexport type PendingRoundRolesVarPopFields = {\n  __typename?: 'PendingRoundRolesVarPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate varSamp on columns */\nexport type PendingRoundRolesVarSampFields = {\n  __typename?: 'PendingRoundRolesVarSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** aggregate variance on columns */\nexport type PendingRoundRolesVarianceFields = {\n  __typename?: 'PendingRoundRolesVarianceFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  id?: Maybe<Scalars['Float']['output']>;\n};\n\n/** Boolean expression to compare columns of type \"project_role_name\". All fields are combined with logical 'AND'. */\nexport type ProjectRoleNameComparisonExp = {\n  _eq?: InputMaybe<Scalars['project_role_name']['input']>;\n  _gt?: InputMaybe<Scalars['project_role_name']['input']>;\n  _gte?: InputMaybe<Scalars['project_role_name']['input']>;\n  _in?: InputMaybe<Array<Scalars['project_role_name']['input']>>;\n  _isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  _lt?: InputMaybe<Scalars['project_role_name']['input']>;\n  _lte?: InputMaybe<Scalars['project_role_name']['input']>;\n  _neq?: InputMaybe<Scalars['project_role_name']['input']>;\n  _nin?: InputMaybe<Array<Scalars['project_role_name']['input']>>;\n};\n\n/** columns and relationships of \"project_roles\" */\nexport type ProjectRoles = {\n  __typename?: 'ProjectRoles';\n  address: Scalars['String']['output'];\n  chainId: Scalars['Int']['output'];\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  /** An object relationship */\n  project?: Maybe<Projects>;\n  projectId: Scalars['String']['output'];\n  role: Scalars['project_role_name']['output'];\n};\n\n/** aggregated selection of \"project_roles\" */\nexport type ProjectRolesAggregate = {\n  __typename?: 'ProjectRolesAggregate';\n  aggregate?: Maybe<ProjectRolesAggregateFields>;\n  nodes: Array<ProjectRoles>;\n};\n\nexport type ProjectRolesAggregateBoolExp = {\n  count?: InputMaybe<ProjectRolesAggregateBoolExpCount>;\n};\n\n/** aggregate fields of \"project_roles\" */\nexport type ProjectRolesAggregateFields = {\n  __typename?: 'ProjectRolesAggregateFields';\n  avg?: Maybe<ProjectRolesAvgFields>;\n  count: Scalars['Int']['output'];\n  max?: Maybe<ProjectRolesMaxFields>;\n  min?: Maybe<ProjectRolesMinFields>;\n  stddev?: Maybe<ProjectRolesStddevFields>;\n  stddevPop?: Maybe<ProjectRolesStddevPopFields>;\n  stddevSamp?: Maybe<ProjectRolesStddevSampFields>;\n  sum?: Maybe<ProjectRolesSumFields>;\n  varPop?: Maybe<ProjectRolesVarPopFields>;\n  varSamp?: Maybe<ProjectRolesVarSampFields>;\n  variance?: Maybe<ProjectRolesVarianceFields>;\n};\n\n\n/** aggregate fields of \"project_roles\" */\nexport type ProjectRolesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<ProjectRolesSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** order by aggregate values of table \"project_roles\" */\nexport type ProjectRolesAggregateOrderBy = {\n  avg?: InputMaybe<ProjectRolesAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<ProjectRolesMaxOrderBy>;\n  min?: InputMaybe<ProjectRolesMinOrderBy>;\n  stddev?: InputMaybe<ProjectRolesStddevOrderBy>;\n  stddevPop?: InputMaybe<ProjectRolesStddevPopOrderBy>;\n  stddevSamp?: InputMaybe<ProjectRolesStddevSampOrderBy>;\n  sum?: InputMaybe<ProjectRolesSumOrderBy>;\n  varPop?: InputMaybe<ProjectRolesVarPopOrderBy>;\n  varSamp?: InputMaybe<ProjectRolesVarSampOrderBy>;\n  variance?: InputMaybe<ProjectRolesVarianceOrderBy>;\n};\n\n/** aggregate avg on columns */\nexport type ProjectRolesAvgFields = {\n  __typename?: 'ProjectRolesAvgFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by avg() on columns of table \"project_roles\" */\nexport type ProjectRolesAvgOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"project_roles\". All fields are combined with a logical 'AND'. */\nexport type ProjectRolesBoolExp = {\n  _and?: InputMaybe<Array<ProjectRolesBoolExp>>;\n  _not?: InputMaybe<ProjectRolesBoolExp>;\n  _or?: InputMaybe<Array<ProjectRolesBoolExp>>;\n  address?: InputMaybe<StringComparisonExp>;\n  chainId?: InputMaybe<IntComparisonExp>;\n  createdAtBlock?: InputMaybe<NumericComparisonExp>;\n  project?: InputMaybe<ProjectsBoolExp>;\n  projectId?: InputMaybe<StringComparisonExp>;\n  role?: InputMaybe<ProjectRoleNameComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type ProjectRolesMaxFields = {\n  __typename?: 'ProjectRolesMaxFields';\n  address?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  projectId?: Maybe<Scalars['String']['output']>;\n  role?: Maybe<Scalars['project_role_name']['output']>;\n};\n\n/** order by max() on columns of table \"project_roles\" */\nexport type ProjectRolesMaxOrderBy = {\n  address?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  projectId?: InputMaybe<OrderBy>;\n  role?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type ProjectRolesMinFields = {\n  __typename?: 'ProjectRolesMinFields';\n  address?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  projectId?: Maybe<Scalars['String']['output']>;\n  role?: Maybe<Scalars['project_role_name']['output']>;\n};\n\n/** order by min() on columns of table \"project_roles\" */\nexport type ProjectRolesMinOrderBy = {\n  address?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  projectId?: InputMaybe<OrderBy>;\n  role?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"project_roles\". */\nexport type ProjectRolesOrderBy = {\n  address?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  project?: InputMaybe<ProjectsOrderBy>;\n  projectId?: InputMaybe<OrderBy>;\n  role?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"project_roles\" */\nexport enum ProjectRolesSelectColumn {\n  /** column name */\n  Address = 'address',\n  /** column name */\n  ChainId = 'chainId',\n  /** column name */\n  CreatedAtBlock = 'createdAtBlock',\n  /** column name */\n  ProjectId = 'projectId',\n  /** column name */\n  Role = 'role'\n}\n\n/** aggregate stddev on columns */\nexport type ProjectRolesStddevFields = {\n  __typename?: 'ProjectRolesStddevFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddev() on columns of table \"project_roles\" */\nexport type ProjectRolesStddevOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevPop on columns */\nexport type ProjectRolesStddevPopFields = {\n  __typename?: 'ProjectRolesStddevPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevPop() on columns of table \"project_roles\" */\nexport type ProjectRolesStddevPopOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevSamp on columns */\nexport type ProjectRolesStddevSampFields = {\n  __typename?: 'ProjectRolesStddevSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevSamp() on columns of table \"project_roles\" */\nexport type ProjectRolesStddevSampOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"project_roles\" */\nexport type ProjectRolesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initialValue: ProjectRolesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type ProjectRolesStreamCursorValueInput = {\n  address?: InputMaybe<Scalars['String']['input']>;\n  chainId?: InputMaybe<Scalars['Int']['input']>;\n  createdAtBlock?: InputMaybe<Scalars['numeric']['input']>;\n  projectId?: InputMaybe<Scalars['String']['input']>;\n  role?: InputMaybe<Scalars['project_role_name']['input']>;\n};\n\n/** aggregate sum on columns */\nexport type ProjectRolesSumFields = {\n  __typename?: 'ProjectRolesSumFields';\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n};\n\n/** order by sum() on columns of table \"project_roles\" */\nexport type ProjectRolesSumOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varPop on columns */\nexport type ProjectRolesVarPopFields = {\n  __typename?: 'ProjectRolesVarPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varPop() on columns of table \"project_roles\" */\nexport type ProjectRolesVarPopOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varSamp on columns */\nexport type ProjectRolesVarSampFields = {\n  __typename?: 'ProjectRolesVarSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varSamp() on columns of table \"project_roles\" */\nexport type ProjectRolesVarSampOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type ProjectRolesVarianceFields = {\n  __typename?: 'ProjectRolesVarianceFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by variance() on columns of table \"project_roles\" */\nexport type ProjectRolesVarianceOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to compare columns of type \"project_type\". All fields are combined with logical 'AND'. */\nexport type ProjectTypeComparisonExp = {\n  _eq?: InputMaybe<Scalars['project_type']['input']>;\n  _gt?: InputMaybe<Scalars['project_type']['input']>;\n  _gte?: InputMaybe<Scalars['project_type']['input']>;\n  _in?: InputMaybe<Array<Scalars['project_type']['input']>>;\n  _isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  _lt?: InputMaybe<Scalars['project_type']['input']>;\n  _lte?: InputMaybe<Scalars['project_type']['input']>;\n  _neq?: InputMaybe<Scalars['project_type']['input']>;\n  _nin?: InputMaybe<Array<Scalars['project_type']['input']>>;\n};\n\n/** columns and relationships of \"projects\" */\nexport type Projects = {\n  __typename?: 'Projects';\n  anchorAddress?: Maybe<Scalars['String']['output']>;\n  /** An array relationship */\n  applications: Array<Applications>;\n  /** An aggregate relationship */\n  applicationsAggregate: ApplicationsAggregate;\n  chainId: Scalars['Int']['output'];\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  createdByAddress?: Maybe<Scalars['String']['output']>;\n  id: Scalars['String']['output'];\n  metadata?: Maybe<Scalars['jsonb']['output']>;\n  metadataCid?: Maybe<Scalars['String']['output']>;\n  name?: Maybe<Scalars['String']['output']>;\n  nonce?: Maybe<Scalars['numeric']['output']>;\n  projectNumber?: Maybe<Scalars['Int']['output']>;\n  /** An array relationship */\n  projectRoles: Array<ProjectRoles>;\n  /** An aggregate relationship */\n  projectRolesAggregate: ProjectRolesAggregate;\n  projectType?: Maybe<Scalars['project_type']['output']>;\n  registryAddress?: Maybe<Scalars['String']['output']>;\n  /** An array relationship */\n  rounds: Array<Rounds>;\n  /** An aggregate relationship */\n  roundsAggregate: RoundsAggregate;\n  tags?: Maybe<Scalars['jsonb']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  updatedAtBlock?: Maybe<Scalars['numeric']['output']>;\n};\n\n\n/** columns and relationships of \"projects\" */\nexport type ProjectsApplicationsArgs = {\n  distinctOn?: InputMaybe<Array<ApplicationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;\n  where?: InputMaybe<ApplicationsBoolExp>;\n};\n\n\n/** columns and relationships of \"projects\" */\nexport type ProjectsApplicationsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<ApplicationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;\n  where?: InputMaybe<ApplicationsBoolExp>;\n};\n\n\n/** columns and relationships of \"projects\" */\nexport type ProjectsMetadataArgs = {\n  path?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** columns and relationships of \"projects\" */\nexport type ProjectsProjectRolesArgs = {\n  distinctOn?: InputMaybe<Array<ProjectRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectRolesOrderBy>>;\n  where?: InputMaybe<ProjectRolesBoolExp>;\n};\n\n\n/** columns and relationships of \"projects\" */\nexport type ProjectsProjectRolesAggregateArgs = {\n  distinctOn?: InputMaybe<Array<ProjectRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectRolesOrderBy>>;\n  where?: InputMaybe<ProjectRolesBoolExp>;\n};\n\n\n/** columns and relationships of \"projects\" */\nexport type ProjectsRoundsArgs = {\n  distinctOn?: InputMaybe<Array<RoundsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<RoundsOrderBy>>;\n  where?: InputMaybe<RoundsBoolExp>;\n};\n\n\n/** columns and relationships of \"projects\" */\nexport type ProjectsRoundsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<RoundsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<RoundsOrderBy>>;\n  where?: InputMaybe<RoundsBoolExp>;\n};\n\n\n/** columns and relationships of \"projects\" */\nexport type ProjectsTagsArgs = {\n  path?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** aggregated selection of \"projects\" */\nexport type ProjectsAggregate = {\n  __typename?: 'ProjectsAggregate';\n  aggregate?: Maybe<ProjectsAggregateFields>;\n  nodes: Array<Projects>;\n};\n\nexport type ProjectsAggregateBoolExp = {\n  count?: InputMaybe<ProjectsAggregateBoolExpCount>;\n};\n\n/** aggregate fields of \"projects\" */\nexport type ProjectsAggregateFields = {\n  __typename?: 'ProjectsAggregateFields';\n  avg?: Maybe<ProjectsAvgFields>;\n  count: Scalars['Int']['output'];\n  max?: Maybe<ProjectsMaxFields>;\n  min?: Maybe<ProjectsMinFields>;\n  stddev?: Maybe<ProjectsStddevFields>;\n  stddevPop?: Maybe<ProjectsStddevPopFields>;\n  stddevSamp?: Maybe<ProjectsStddevSampFields>;\n  sum?: Maybe<ProjectsSumFields>;\n  varPop?: Maybe<ProjectsVarPopFields>;\n  varSamp?: Maybe<ProjectsVarSampFields>;\n  variance?: Maybe<ProjectsVarianceFields>;\n};\n\n\n/** aggregate fields of \"projects\" */\nexport type ProjectsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<ProjectsSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** order by aggregate values of table \"projects\" */\nexport type ProjectsAggregateOrderBy = {\n  avg?: InputMaybe<ProjectsAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<ProjectsMaxOrderBy>;\n  min?: InputMaybe<ProjectsMinOrderBy>;\n  stddev?: InputMaybe<ProjectsStddevOrderBy>;\n  stddevPop?: InputMaybe<ProjectsStddevPopOrderBy>;\n  stddevSamp?: InputMaybe<ProjectsStddevSampOrderBy>;\n  sum?: InputMaybe<ProjectsSumOrderBy>;\n  varPop?: InputMaybe<ProjectsVarPopOrderBy>;\n  varSamp?: InputMaybe<ProjectsVarSampOrderBy>;\n  variance?: InputMaybe<ProjectsVarianceOrderBy>;\n};\n\n/** aggregate avg on columns */\nexport type ProjectsAvgFields = {\n  __typename?: 'ProjectsAvgFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  nonce?: Maybe<Scalars['Float']['output']>;\n  projectNumber?: Maybe<Scalars['Float']['output']>;\n  updatedAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by avg() on columns of table \"projects\" */\nexport type ProjectsAvgOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  nonce?: InputMaybe<OrderBy>;\n  projectNumber?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"projects\". All fields are combined with a logical 'AND'. */\nexport type ProjectsBoolExp = {\n  _and?: InputMaybe<Array<ProjectsBoolExp>>;\n  _not?: InputMaybe<ProjectsBoolExp>;\n  _or?: InputMaybe<Array<ProjectsBoolExp>>;\n  anchorAddress?: InputMaybe<StringComparisonExp>;\n  applications?: InputMaybe<ApplicationsBoolExp>;\n  applicationsAggregate?: InputMaybe<ApplicationsAggregateBoolExp>;\n  chainId?: InputMaybe<IntComparisonExp>;\n  createdAtBlock?: InputMaybe<NumericComparisonExp>;\n  createdByAddress?: InputMaybe<StringComparisonExp>;\n  id?: InputMaybe<StringComparisonExp>;\n  metadata?: InputMaybe<JsonbComparisonExp>;\n  metadataCid?: InputMaybe<StringComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  nonce?: InputMaybe<NumericComparisonExp>;\n  projectNumber?: InputMaybe<IntComparisonExp>;\n  projectRoles?: InputMaybe<ProjectRolesBoolExp>;\n  projectRolesAggregate?: InputMaybe<ProjectRolesAggregateBoolExp>;\n  projectType?: InputMaybe<ProjectTypeComparisonExp>;\n  registryAddress?: InputMaybe<StringComparisonExp>;\n  rounds?: InputMaybe<RoundsBoolExp>;\n  roundsAggregate?: InputMaybe<RoundsAggregateBoolExp>;\n  tags?: InputMaybe<JsonbComparisonExp>;\n  timestamp?: InputMaybe<TimestamptzComparisonExp>;\n  updatedAtBlock?: InputMaybe<NumericComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type ProjectsMaxFields = {\n  __typename?: 'ProjectsMaxFields';\n  anchorAddress?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  createdByAddress?: Maybe<Scalars['String']['output']>;\n  id?: Maybe<Scalars['String']['output']>;\n  metadataCid?: Maybe<Scalars['String']['output']>;\n  name?: Maybe<Scalars['String']['output']>;\n  nonce?: Maybe<Scalars['numeric']['output']>;\n  projectNumber?: Maybe<Scalars['Int']['output']>;\n  projectType?: Maybe<Scalars['project_type']['output']>;\n  registryAddress?: Maybe<Scalars['String']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  updatedAtBlock?: Maybe<Scalars['numeric']['output']>;\n};\n\n/** order by max() on columns of table \"projects\" */\nexport type ProjectsMaxOrderBy = {\n  anchorAddress?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  createdByAddress?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  metadataCid?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  nonce?: InputMaybe<OrderBy>;\n  projectNumber?: InputMaybe<OrderBy>;\n  projectType?: InputMaybe<OrderBy>;\n  registryAddress?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type ProjectsMinFields = {\n  __typename?: 'ProjectsMinFields';\n  anchorAddress?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  createdByAddress?: Maybe<Scalars['String']['output']>;\n  id?: Maybe<Scalars['String']['output']>;\n  metadataCid?: Maybe<Scalars['String']['output']>;\n  name?: Maybe<Scalars['String']['output']>;\n  nonce?: Maybe<Scalars['numeric']['output']>;\n  projectNumber?: Maybe<Scalars['Int']['output']>;\n  projectType?: Maybe<Scalars['project_type']['output']>;\n  registryAddress?: Maybe<Scalars['String']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  updatedAtBlock?: Maybe<Scalars['numeric']['output']>;\n};\n\n/** order by min() on columns of table \"projects\" */\nexport type ProjectsMinOrderBy = {\n  anchorAddress?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  createdByAddress?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  metadataCid?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  nonce?: InputMaybe<OrderBy>;\n  projectNumber?: InputMaybe<OrderBy>;\n  projectType?: InputMaybe<OrderBy>;\n  registryAddress?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"projects\". */\nexport type ProjectsOrderBy = {\n  anchorAddress?: InputMaybe<OrderBy>;\n  applicationsAggregate?: InputMaybe<ApplicationsAggregateOrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  createdByAddress?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  metadata?: InputMaybe<OrderBy>;\n  metadataCid?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  nonce?: InputMaybe<OrderBy>;\n  projectNumber?: InputMaybe<OrderBy>;\n  projectRolesAggregate?: InputMaybe<ProjectRolesAggregateOrderBy>;\n  projectType?: InputMaybe<OrderBy>;\n  registryAddress?: InputMaybe<OrderBy>;\n  roundsAggregate?: InputMaybe<RoundsAggregateOrderBy>;\n  tags?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"projects\" */\nexport enum ProjectsSelectColumn {\n  /** column name */\n  AnchorAddress = 'anchorAddress',\n  /** column name */\n  ChainId = 'chainId',\n  /** column name */\n  CreatedAtBlock = 'createdAtBlock',\n  /** column name */\n  CreatedByAddress = 'createdByAddress',\n  /** column name */\n  Id = 'id',\n  /** column name */\n  Metadata = 'metadata',\n  /** column name */\n  MetadataCid = 'metadataCid',\n  /** column name */\n  Name = 'name',\n  /** column name */\n  Nonce = 'nonce',\n  /** column name */\n  ProjectNumber = 'projectNumber',\n  /** column name */\n  ProjectType = 'projectType',\n  /** column name */\n  RegistryAddress = 'registryAddress',\n  /** column name */\n  Tags = 'tags',\n  /** column name */\n  Timestamp = 'timestamp',\n  /** column name */\n  UpdatedAtBlock = 'updatedAtBlock'\n}\n\n/** aggregate stddev on columns */\nexport type ProjectsStddevFields = {\n  __typename?: 'ProjectsStddevFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  nonce?: Maybe<Scalars['Float']['output']>;\n  projectNumber?: Maybe<Scalars['Float']['output']>;\n  updatedAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddev() on columns of table \"projects\" */\nexport type ProjectsStddevOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  nonce?: InputMaybe<OrderBy>;\n  projectNumber?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevPop on columns */\nexport type ProjectsStddevPopFields = {\n  __typename?: 'ProjectsStddevPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  nonce?: Maybe<Scalars['Float']['output']>;\n  projectNumber?: Maybe<Scalars['Float']['output']>;\n  updatedAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevPop() on columns of table \"projects\" */\nexport type ProjectsStddevPopOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  nonce?: InputMaybe<OrderBy>;\n  projectNumber?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevSamp on columns */\nexport type ProjectsStddevSampFields = {\n  __typename?: 'ProjectsStddevSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  nonce?: Maybe<Scalars['Float']['output']>;\n  projectNumber?: Maybe<Scalars['Float']['output']>;\n  updatedAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevSamp() on columns of table \"projects\" */\nexport type ProjectsStddevSampOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  nonce?: InputMaybe<OrderBy>;\n  projectNumber?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"projects\" */\nexport type ProjectsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initialValue: ProjectsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type ProjectsStreamCursorValueInput = {\n  anchorAddress?: InputMaybe<Scalars['String']['input']>;\n  chainId?: InputMaybe<Scalars['Int']['input']>;\n  createdAtBlock?: InputMaybe<Scalars['numeric']['input']>;\n  createdByAddress?: InputMaybe<Scalars['String']['input']>;\n  id?: InputMaybe<Scalars['String']['input']>;\n  metadata?: InputMaybe<Scalars['jsonb']['input']>;\n  metadataCid?: InputMaybe<Scalars['String']['input']>;\n  name?: InputMaybe<Scalars['String']['input']>;\n  nonce?: InputMaybe<Scalars['numeric']['input']>;\n  projectNumber?: InputMaybe<Scalars['Int']['input']>;\n  projectType?: InputMaybe<Scalars['project_type']['input']>;\n  registryAddress?: InputMaybe<Scalars['String']['input']>;\n  tags?: InputMaybe<Scalars['jsonb']['input']>;\n  timestamp?: InputMaybe<Scalars['timestamptz']['input']>;\n  updatedAtBlock?: InputMaybe<Scalars['numeric']['input']>;\n};\n\n/** aggregate sum on columns */\nexport type ProjectsSumFields = {\n  __typename?: 'ProjectsSumFields';\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  nonce?: Maybe<Scalars['numeric']['output']>;\n  projectNumber?: Maybe<Scalars['Int']['output']>;\n  updatedAtBlock?: Maybe<Scalars['numeric']['output']>;\n};\n\n/** order by sum() on columns of table \"projects\" */\nexport type ProjectsSumOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  nonce?: InputMaybe<OrderBy>;\n  projectNumber?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varPop on columns */\nexport type ProjectsVarPopFields = {\n  __typename?: 'ProjectsVarPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  nonce?: Maybe<Scalars['Float']['output']>;\n  projectNumber?: Maybe<Scalars['Float']['output']>;\n  updatedAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varPop() on columns of table \"projects\" */\nexport type ProjectsVarPopOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  nonce?: InputMaybe<OrderBy>;\n  projectNumber?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varSamp on columns */\nexport type ProjectsVarSampFields = {\n  __typename?: 'ProjectsVarSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  nonce?: Maybe<Scalars['Float']['output']>;\n  projectNumber?: Maybe<Scalars['Float']['output']>;\n  updatedAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varSamp() on columns of table \"projects\" */\nexport type ProjectsVarSampOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  nonce?: InputMaybe<OrderBy>;\n  projectNumber?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type ProjectsVarianceFields = {\n  __typename?: 'ProjectsVarianceFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  nonce?: Maybe<Scalars['Float']['output']>;\n  projectNumber?: Maybe<Scalars['Float']['output']>;\n  updatedAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by variance() on columns of table \"projects\" */\nexport type ProjectsVarianceOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  nonce?: InputMaybe<OrderBy>;\n  projectNumber?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to compare columns of type \"round_role_name\". All fields are combined with logical 'AND'. */\nexport type RoundRoleNameComparisonExp = {\n  _eq?: InputMaybe<Scalars['round_role_name']['input']>;\n  _gt?: InputMaybe<Scalars['round_role_name']['input']>;\n  _gte?: InputMaybe<Scalars['round_role_name']['input']>;\n  _in?: InputMaybe<Array<Scalars['round_role_name']['input']>>;\n  _isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  _lt?: InputMaybe<Scalars['round_role_name']['input']>;\n  _lte?: InputMaybe<Scalars['round_role_name']['input']>;\n  _neq?: InputMaybe<Scalars['round_role_name']['input']>;\n  _nin?: InputMaybe<Array<Scalars['round_role_name']['input']>>;\n};\n\n/** columns and relationships of \"round_roles\" */\nexport type RoundRoles = {\n  __typename?: 'RoundRoles';\n  address: Scalars['String']['output'];\n  chainId: Scalars['Int']['output'];\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  role: Scalars['round_role_name']['output'];\n  /** An object relationship */\n  round?: Maybe<Rounds>;\n  roundId: Scalars['String']['output'];\n};\n\n/** aggregated selection of \"round_roles\" */\nexport type RoundRolesAggregate = {\n  __typename?: 'RoundRolesAggregate';\n  aggregate?: Maybe<RoundRolesAggregateFields>;\n  nodes: Array<RoundRoles>;\n};\n\nexport type RoundRolesAggregateBoolExp = {\n  count?: InputMaybe<RoundRolesAggregateBoolExpCount>;\n};\n\n/** aggregate fields of \"round_roles\" */\nexport type RoundRolesAggregateFields = {\n  __typename?: 'RoundRolesAggregateFields';\n  avg?: Maybe<RoundRolesAvgFields>;\n  count: Scalars['Int']['output'];\n  max?: Maybe<RoundRolesMaxFields>;\n  min?: Maybe<RoundRolesMinFields>;\n  stddev?: Maybe<RoundRolesStddevFields>;\n  stddevPop?: Maybe<RoundRolesStddevPopFields>;\n  stddevSamp?: Maybe<RoundRolesStddevSampFields>;\n  sum?: Maybe<RoundRolesSumFields>;\n  varPop?: Maybe<RoundRolesVarPopFields>;\n  varSamp?: Maybe<RoundRolesVarSampFields>;\n  variance?: Maybe<RoundRolesVarianceFields>;\n};\n\n\n/** aggregate fields of \"round_roles\" */\nexport type RoundRolesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<RoundRolesSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** order by aggregate values of table \"round_roles\" */\nexport type RoundRolesAggregateOrderBy = {\n  avg?: InputMaybe<RoundRolesAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<RoundRolesMaxOrderBy>;\n  min?: InputMaybe<RoundRolesMinOrderBy>;\n  stddev?: InputMaybe<RoundRolesStddevOrderBy>;\n  stddevPop?: InputMaybe<RoundRolesStddevPopOrderBy>;\n  stddevSamp?: InputMaybe<RoundRolesStddevSampOrderBy>;\n  sum?: InputMaybe<RoundRolesSumOrderBy>;\n  varPop?: InputMaybe<RoundRolesVarPopOrderBy>;\n  varSamp?: InputMaybe<RoundRolesVarSampOrderBy>;\n  variance?: InputMaybe<RoundRolesVarianceOrderBy>;\n};\n\n/** aggregate avg on columns */\nexport type RoundRolesAvgFields = {\n  __typename?: 'RoundRolesAvgFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by avg() on columns of table \"round_roles\" */\nexport type RoundRolesAvgOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"round_roles\". All fields are combined with a logical 'AND'. */\nexport type RoundRolesBoolExp = {\n  _and?: InputMaybe<Array<RoundRolesBoolExp>>;\n  _not?: InputMaybe<RoundRolesBoolExp>;\n  _or?: InputMaybe<Array<RoundRolesBoolExp>>;\n  address?: InputMaybe<StringComparisonExp>;\n  chainId?: InputMaybe<IntComparisonExp>;\n  createdAtBlock?: InputMaybe<NumericComparisonExp>;\n  role?: InputMaybe<RoundRoleNameComparisonExp>;\n  round?: InputMaybe<RoundsBoolExp>;\n  roundId?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type RoundRolesMaxFields = {\n  __typename?: 'RoundRolesMaxFields';\n  address?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  role?: Maybe<Scalars['round_role_name']['output']>;\n  roundId?: Maybe<Scalars['String']['output']>;\n};\n\n/** order by max() on columns of table \"round_roles\" */\nexport type RoundRolesMaxOrderBy = {\n  address?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  role?: InputMaybe<OrderBy>;\n  roundId?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type RoundRolesMinFields = {\n  __typename?: 'RoundRolesMinFields';\n  address?: Maybe<Scalars['String']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  role?: Maybe<Scalars['round_role_name']['output']>;\n  roundId?: Maybe<Scalars['String']['output']>;\n};\n\n/** order by min() on columns of table \"round_roles\" */\nexport type RoundRolesMinOrderBy = {\n  address?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  role?: InputMaybe<OrderBy>;\n  roundId?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"round_roles\". */\nexport type RoundRolesOrderBy = {\n  address?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  role?: InputMaybe<OrderBy>;\n  round?: InputMaybe<RoundsOrderBy>;\n  roundId?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"round_roles\" */\nexport enum RoundRolesSelectColumn {\n  /** column name */\n  Address = 'address',\n  /** column name */\n  ChainId = 'chainId',\n  /** column name */\n  CreatedAtBlock = 'createdAtBlock',\n  /** column name */\n  Role = 'role',\n  /** column name */\n  RoundId = 'roundId'\n}\n\n/** aggregate stddev on columns */\nexport type RoundRolesStddevFields = {\n  __typename?: 'RoundRolesStddevFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddev() on columns of table \"round_roles\" */\nexport type RoundRolesStddevOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevPop on columns */\nexport type RoundRolesStddevPopFields = {\n  __typename?: 'RoundRolesStddevPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevPop() on columns of table \"round_roles\" */\nexport type RoundRolesStddevPopOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevSamp on columns */\nexport type RoundRolesStddevSampFields = {\n  __typename?: 'RoundRolesStddevSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevSamp() on columns of table \"round_roles\" */\nexport type RoundRolesStddevSampOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"round_roles\" */\nexport type RoundRolesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initialValue: RoundRolesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type RoundRolesStreamCursorValueInput = {\n  address?: InputMaybe<Scalars['String']['input']>;\n  chainId?: InputMaybe<Scalars['Int']['input']>;\n  createdAtBlock?: InputMaybe<Scalars['numeric']['input']>;\n  role?: InputMaybe<Scalars['round_role_name']['input']>;\n  roundId?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** aggregate sum on columns */\nexport type RoundRolesSumFields = {\n  __typename?: 'RoundRolesSumFields';\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n};\n\n/** order by sum() on columns of table \"round_roles\" */\nexport type RoundRolesSumOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varPop on columns */\nexport type RoundRolesVarPopFields = {\n  __typename?: 'RoundRolesVarPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varPop() on columns of table \"round_roles\" */\nexport type RoundRolesVarPopOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varSamp on columns */\nexport type RoundRolesVarSampFields = {\n  __typename?: 'RoundRolesVarSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varSamp() on columns of table \"round_roles\" */\nexport type RoundRolesVarSampOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type RoundRolesVarianceFields = {\n  __typename?: 'RoundRolesVarianceFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by variance() on columns of table \"round_roles\" */\nexport type RoundRolesVarianceOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"rounds\" */\nexport type Rounds = {\n  __typename?: 'Rounds';\n  adminRole?: Maybe<Scalars['String']['output']>;\n  applicationMetadata?: Maybe<Scalars['jsonb']['output']>;\n  applicationMetadataCid?: Maybe<Scalars['String']['output']>;\n  /** An array relationship */\n  applications: Array<Applications>;\n  /** An aggregate relationship */\n  applicationsAggregate: ApplicationsAggregate;\n  applicationsEndTime?: Maybe<Scalars['timestamptz']['output']>;\n  applicationsStartTime?: Maybe<Scalars['timestamptz']['output']>;\n  chainId: Scalars['Int']['output'];\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  createdByAddress?: Maybe<Scalars['String']['output']>;\n  /** An array relationship */\n  donations: Array<Donations>;\n  /** An aggregate relationship */\n  donationsAggregate: DonationsAggregate;\n  donationsEndTime?: Maybe<Scalars['timestamptz']['output']>;\n  donationsStartTime?: Maybe<Scalars['timestamptz']['output']>;\n  fundedAmount?: Maybe<Scalars['numeric']['output']>;\n  fundedAmountInUsd?: Maybe<Scalars['numeric']['output']>;\n  id: Scalars['String']['output'];\n  managerRole?: Maybe<Scalars['String']['output']>;\n  matchAmount?: Maybe<Scalars['numeric']['output']>;\n  matchAmountInUsd?: Maybe<Scalars['numeric']['output']>;\n  matchTokenAddress?: Maybe<Scalars['String']['output']>;\n  matchingDistribution?: Maybe<Scalars['jsonb']['output']>;\n  /** An object relationship */\n  project?: Maybe<Projects>;\n  projectId?: Maybe<Scalars['String']['output']>;\n  readyForPayoutTransaction?: Maybe<Scalars['String']['output']>;\n  roundMetadata?: Maybe<Scalars['jsonb']['output']>;\n  roundMetadataCid?: Maybe<Scalars['String']['output']>;\n  /** An array relationship */\n  roundRoles: Array<RoundRoles>;\n  /** An aggregate relationship */\n  roundRolesAggregate: RoundRolesAggregate;\n  strategyAddress?: Maybe<Scalars['String']['output']>;\n  strategyId?: Maybe<Scalars['String']['output']>;\n  strategyName?: Maybe<Scalars['String']['output']>;\n  tags?: Maybe<Scalars['jsonb']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['numeric']['output']>;\n  totalDistributed?: Maybe<Scalars['numeric']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Int']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Int']['output']>;\n  updatedAtBlock?: Maybe<Scalars['numeric']['output']>;\n};\n\n\n/** columns and relationships of \"rounds\" */\nexport type RoundsApplicationMetadataArgs = {\n  path?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** columns and relationships of \"rounds\" */\nexport type RoundsApplicationsArgs = {\n  distinctOn?: InputMaybe<Array<ApplicationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;\n  where?: InputMaybe<ApplicationsBoolExp>;\n};\n\n\n/** columns and relationships of \"rounds\" */\nexport type RoundsApplicationsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<ApplicationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;\n  where?: InputMaybe<ApplicationsBoolExp>;\n};\n\n\n/** columns and relationships of \"rounds\" */\nexport type RoundsDonationsArgs = {\n  distinctOn?: InputMaybe<Array<DonationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<DonationsOrderBy>>;\n  where?: InputMaybe<DonationsBoolExp>;\n};\n\n\n/** columns and relationships of \"rounds\" */\nexport type RoundsDonationsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<DonationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<DonationsOrderBy>>;\n  where?: InputMaybe<DonationsBoolExp>;\n};\n\n\n/** columns and relationships of \"rounds\" */\nexport type RoundsMatchingDistributionArgs = {\n  path?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** columns and relationships of \"rounds\" */\nexport type RoundsRoundMetadataArgs = {\n  path?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** columns and relationships of \"rounds\" */\nexport type RoundsRoundRolesArgs = {\n  distinctOn?: InputMaybe<Array<RoundRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<RoundRolesOrderBy>>;\n  where?: InputMaybe<RoundRolesBoolExp>;\n};\n\n\n/** columns and relationships of \"rounds\" */\nexport type RoundsRoundRolesAggregateArgs = {\n  distinctOn?: InputMaybe<Array<RoundRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<RoundRolesOrderBy>>;\n  where?: InputMaybe<RoundRolesBoolExp>;\n};\n\n\n/** columns and relationships of \"rounds\" */\nexport type RoundsTagsArgs = {\n  path?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** aggregated selection of \"rounds\" */\nexport type RoundsAggregate = {\n  __typename?: 'RoundsAggregate';\n  aggregate?: Maybe<RoundsAggregateFields>;\n  nodes: Array<Rounds>;\n};\n\nexport type RoundsAggregateBoolExp = {\n  count?: InputMaybe<RoundsAggregateBoolExpCount>;\n};\n\n/** aggregate fields of \"rounds\" */\nexport type RoundsAggregateFields = {\n  __typename?: 'RoundsAggregateFields';\n  avg?: Maybe<RoundsAvgFields>;\n  count: Scalars['Int']['output'];\n  max?: Maybe<RoundsMaxFields>;\n  min?: Maybe<RoundsMinFields>;\n  stddev?: Maybe<RoundsStddevFields>;\n  stddevPop?: Maybe<RoundsStddevPopFields>;\n  stddevSamp?: Maybe<RoundsStddevSampFields>;\n  sum?: Maybe<RoundsSumFields>;\n  varPop?: Maybe<RoundsVarPopFields>;\n  varSamp?: Maybe<RoundsVarSampFields>;\n  variance?: Maybe<RoundsVarianceFields>;\n};\n\n\n/** aggregate fields of \"rounds\" */\nexport type RoundsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<RoundsSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n};\n\n/** order by aggregate values of table \"rounds\" */\nexport type RoundsAggregateOrderBy = {\n  avg?: InputMaybe<RoundsAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<RoundsMaxOrderBy>;\n  min?: InputMaybe<RoundsMinOrderBy>;\n  stddev?: InputMaybe<RoundsStddevOrderBy>;\n  stddevPop?: InputMaybe<RoundsStddevPopOrderBy>;\n  stddevSamp?: InputMaybe<RoundsStddevSampOrderBy>;\n  sum?: InputMaybe<RoundsSumOrderBy>;\n  varPop?: InputMaybe<RoundsVarPopOrderBy>;\n  varSamp?: InputMaybe<RoundsVarSampOrderBy>;\n  variance?: InputMaybe<RoundsVarianceOrderBy>;\n};\n\n/** aggregate avg on columns */\nexport type RoundsAvgFields = {\n  __typename?: 'RoundsAvgFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  fundedAmount?: Maybe<Scalars['Float']['output']>;\n  fundedAmountInUsd?: Maybe<Scalars['Float']['output']>;\n  matchAmount?: Maybe<Scalars['Float']['output']>;\n  matchAmountInUsd?: Maybe<Scalars['Float']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['Float']['output']>;\n  totalDistributed?: Maybe<Scalars['Float']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Float']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Float']['output']>;\n  updatedAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by avg() on columns of table \"rounds\" */\nexport type RoundsAvgOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  fundedAmount?: InputMaybe<OrderBy>;\n  fundedAmountInUsd?: InputMaybe<OrderBy>;\n  matchAmount?: InputMaybe<OrderBy>;\n  matchAmountInUsd?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDistributed?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"rounds\". All fields are combined with a logical 'AND'. */\nexport type RoundsBoolExp = {\n  _and?: InputMaybe<Array<RoundsBoolExp>>;\n  _not?: InputMaybe<RoundsBoolExp>;\n  _or?: InputMaybe<Array<RoundsBoolExp>>;\n  adminRole?: InputMaybe<StringComparisonExp>;\n  applicationMetadata?: InputMaybe<JsonbComparisonExp>;\n  applicationMetadataCid?: InputMaybe<StringComparisonExp>;\n  applications?: InputMaybe<ApplicationsBoolExp>;\n  applicationsAggregate?: InputMaybe<ApplicationsAggregateBoolExp>;\n  applicationsEndTime?: InputMaybe<TimestamptzComparisonExp>;\n  applicationsStartTime?: InputMaybe<TimestamptzComparisonExp>;\n  chainId?: InputMaybe<IntComparisonExp>;\n  createdAtBlock?: InputMaybe<NumericComparisonExp>;\n  createdByAddress?: InputMaybe<StringComparisonExp>;\n  donations?: InputMaybe<DonationsBoolExp>;\n  donationsAggregate?: InputMaybe<DonationsAggregateBoolExp>;\n  donationsEndTime?: InputMaybe<TimestamptzComparisonExp>;\n  donationsStartTime?: InputMaybe<TimestamptzComparisonExp>;\n  fundedAmount?: InputMaybe<NumericComparisonExp>;\n  fundedAmountInUsd?: InputMaybe<NumericComparisonExp>;\n  id?: InputMaybe<StringComparisonExp>;\n  managerRole?: InputMaybe<StringComparisonExp>;\n  matchAmount?: InputMaybe<NumericComparisonExp>;\n  matchAmountInUsd?: InputMaybe<NumericComparisonExp>;\n  matchTokenAddress?: InputMaybe<StringComparisonExp>;\n  matchingDistribution?: InputMaybe<JsonbComparisonExp>;\n  project?: InputMaybe<ProjectsBoolExp>;\n  projectId?: InputMaybe<StringComparisonExp>;\n  readyForPayoutTransaction?: InputMaybe<StringComparisonExp>;\n  roundMetadata?: InputMaybe<JsonbComparisonExp>;\n  roundMetadataCid?: InputMaybe<StringComparisonExp>;\n  roundRoles?: InputMaybe<RoundRolesBoolExp>;\n  roundRolesAggregate?: InputMaybe<RoundRolesAggregateBoolExp>;\n  strategyAddress?: InputMaybe<StringComparisonExp>;\n  strategyId?: InputMaybe<StringComparisonExp>;\n  strategyName?: InputMaybe<StringComparisonExp>;\n  tags?: InputMaybe<JsonbComparisonExp>;\n  timestamp?: InputMaybe<TimestamptzComparisonExp>;\n  totalAmountDonatedInUsd?: InputMaybe<NumericComparisonExp>;\n  totalDistributed?: InputMaybe<NumericComparisonExp>;\n  totalDonationsCount?: InputMaybe<IntComparisonExp>;\n  uniqueDonorsCount?: InputMaybe<IntComparisonExp>;\n  updatedAtBlock?: InputMaybe<NumericComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type RoundsMaxFields = {\n  __typename?: 'RoundsMaxFields';\n  adminRole?: Maybe<Scalars['String']['output']>;\n  applicationMetadataCid?: Maybe<Scalars['String']['output']>;\n  applicationsEndTime?: Maybe<Scalars['timestamptz']['output']>;\n  applicationsStartTime?: Maybe<Scalars['timestamptz']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  createdByAddress?: Maybe<Scalars['String']['output']>;\n  donationsEndTime?: Maybe<Scalars['timestamptz']['output']>;\n  donationsStartTime?: Maybe<Scalars['timestamptz']['output']>;\n  fundedAmount?: Maybe<Scalars['numeric']['output']>;\n  fundedAmountInUsd?: Maybe<Scalars['numeric']['output']>;\n  id?: Maybe<Scalars['String']['output']>;\n  managerRole?: Maybe<Scalars['String']['output']>;\n  matchAmount?: Maybe<Scalars['numeric']['output']>;\n  matchAmountInUsd?: Maybe<Scalars['numeric']['output']>;\n  matchTokenAddress?: Maybe<Scalars['String']['output']>;\n  projectId?: Maybe<Scalars['String']['output']>;\n  readyForPayoutTransaction?: Maybe<Scalars['String']['output']>;\n  roundMetadataCid?: Maybe<Scalars['String']['output']>;\n  strategyAddress?: Maybe<Scalars['String']['output']>;\n  strategyId?: Maybe<Scalars['String']['output']>;\n  strategyName?: Maybe<Scalars['String']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['numeric']['output']>;\n  totalDistributed?: Maybe<Scalars['numeric']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Int']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Int']['output']>;\n  updatedAtBlock?: Maybe<Scalars['numeric']['output']>;\n};\n\n/** order by max() on columns of table \"rounds\" */\nexport type RoundsMaxOrderBy = {\n  adminRole?: InputMaybe<OrderBy>;\n  applicationMetadataCid?: InputMaybe<OrderBy>;\n  applicationsEndTime?: InputMaybe<OrderBy>;\n  applicationsStartTime?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  createdByAddress?: InputMaybe<OrderBy>;\n  donationsEndTime?: InputMaybe<OrderBy>;\n  donationsStartTime?: InputMaybe<OrderBy>;\n  fundedAmount?: InputMaybe<OrderBy>;\n  fundedAmountInUsd?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  managerRole?: InputMaybe<OrderBy>;\n  matchAmount?: InputMaybe<OrderBy>;\n  matchAmountInUsd?: InputMaybe<OrderBy>;\n  matchTokenAddress?: InputMaybe<OrderBy>;\n  projectId?: InputMaybe<OrderBy>;\n  readyForPayoutTransaction?: InputMaybe<OrderBy>;\n  roundMetadataCid?: InputMaybe<OrderBy>;\n  strategyAddress?: InputMaybe<OrderBy>;\n  strategyId?: InputMaybe<OrderBy>;\n  strategyName?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDistributed?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type RoundsMinFields = {\n  __typename?: 'RoundsMinFields';\n  adminRole?: Maybe<Scalars['String']['output']>;\n  applicationMetadataCid?: Maybe<Scalars['String']['output']>;\n  applicationsEndTime?: Maybe<Scalars['timestamptz']['output']>;\n  applicationsStartTime?: Maybe<Scalars['timestamptz']['output']>;\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  createdByAddress?: Maybe<Scalars['String']['output']>;\n  donationsEndTime?: Maybe<Scalars['timestamptz']['output']>;\n  donationsStartTime?: Maybe<Scalars['timestamptz']['output']>;\n  fundedAmount?: Maybe<Scalars['numeric']['output']>;\n  fundedAmountInUsd?: Maybe<Scalars['numeric']['output']>;\n  id?: Maybe<Scalars['String']['output']>;\n  managerRole?: Maybe<Scalars['String']['output']>;\n  matchAmount?: Maybe<Scalars['numeric']['output']>;\n  matchAmountInUsd?: Maybe<Scalars['numeric']['output']>;\n  matchTokenAddress?: Maybe<Scalars['String']['output']>;\n  projectId?: Maybe<Scalars['String']['output']>;\n  readyForPayoutTransaction?: Maybe<Scalars['String']['output']>;\n  roundMetadataCid?: Maybe<Scalars['String']['output']>;\n  strategyAddress?: Maybe<Scalars['String']['output']>;\n  strategyId?: Maybe<Scalars['String']['output']>;\n  strategyName?: Maybe<Scalars['String']['output']>;\n  timestamp?: Maybe<Scalars['timestamptz']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['numeric']['output']>;\n  totalDistributed?: Maybe<Scalars['numeric']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Int']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Int']['output']>;\n  updatedAtBlock?: Maybe<Scalars['numeric']['output']>;\n};\n\n/** order by min() on columns of table \"rounds\" */\nexport type RoundsMinOrderBy = {\n  adminRole?: InputMaybe<OrderBy>;\n  applicationMetadataCid?: InputMaybe<OrderBy>;\n  applicationsEndTime?: InputMaybe<OrderBy>;\n  applicationsStartTime?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  createdByAddress?: InputMaybe<OrderBy>;\n  donationsEndTime?: InputMaybe<OrderBy>;\n  donationsStartTime?: InputMaybe<OrderBy>;\n  fundedAmount?: InputMaybe<OrderBy>;\n  fundedAmountInUsd?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  managerRole?: InputMaybe<OrderBy>;\n  matchAmount?: InputMaybe<OrderBy>;\n  matchAmountInUsd?: InputMaybe<OrderBy>;\n  matchTokenAddress?: InputMaybe<OrderBy>;\n  projectId?: InputMaybe<OrderBy>;\n  readyForPayoutTransaction?: InputMaybe<OrderBy>;\n  roundMetadataCid?: InputMaybe<OrderBy>;\n  strategyAddress?: InputMaybe<OrderBy>;\n  strategyId?: InputMaybe<OrderBy>;\n  strategyName?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDistributed?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** Ordering options when selecting data from \"rounds\". */\nexport type RoundsOrderBy = {\n  adminRole?: InputMaybe<OrderBy>;\n  applicationMetadata?: InputMaybe<OrderBy>;\n  applicationMetadataCid?: InputMaybe<OrderBy>;\n  applicationsAggregate?: InputMaybe<ApplicationsAggregateOrderBy>;\n  applicationsEndTime?: InputMaybe<OrderBy>;\n  applicationsStartTime?: InputMaybe<OrderBy>;\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  createdByAddress?: InputMaybe<OrderBy>;\n  donationsAggregate?: InputMaybe<DonationsAggregateOrderBy>;\n  donationsEndTime?: InputMaybe<OrderBy>;\n  donationsStartTime?: InputMaybe<OrderBy>;\n  fundedAmount?: InputMaybe<OrderBy>;\n  fundedAmountInUsd?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  managerRole?: InputMaybe<OrderBy>;\n  matchAmount?: InputMaybe<OrderBy>;\n  matchAmountInUsd?: InputMaybe<OrderBy>;\n  matchTokenAddress?: InputMaybe<OrderBy>;\n  matchingDistribution?: InputMaybe<OrderBy>;\n  project?: InputMaybe<ProjectsOrderBy>;\n  projectId?: InputMaybe<OrderBy>;\n  readyForPayoutTransaction?: InputMaybe<OrderBy>;\n  roundMetadata?: InputMaybe<OrderBy>;\n  roundMetadataCid?: InputMaybe<OrderBy>;\n  roundRolesAggregate?: InputMaybe<RoundRolesAggregateOrderBy>;\n  strategyAddress?: InputMaybe<OrderBy>;\n  strategyId?: InputMaybe<OrderBy>;\n  strategyName?: InputMaybe<OrderBy>;\n  tags?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDistributed?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"rounds\" */\nexport enum RoundsSelectColumn {\n  /** column name */\n  AdminRole = 'adminRole',\n  /** column name */\n  ApplicationMetadata = 'applicationMetadata',\n  /** column name */\n  ApplicationMetadataCid = 'applicationMetadataCid',\n  /** column name */\n  ApplicationsEndTime = 'applicationsEndTime',\n  /** column name */\n  ApplicationsStartTime = 'applicationsStartTime',\n  /** column name */\n  ChainId = 'chainId',\n  /** column name */\n  CreatedAtBlock = 'createdAtBlock',\n  /** column name */\n  CreatedByAddress = 'createdByAddress',\n  /** column name */\n  DonationsEndTime = 'donationsEndTime',\n  /** column name */\n  DonationsStartTime = 'donationsStartTime',\n  /** column name */\n  FundedAmount = 'fundedAmount',\n  /** column name */\n  FundedAmountInUsd = 'fundedAmountInUsd',\n  /** column name */\n  Id = 'id',\n  /** column name */\n  ManagerRole = 'managerRole',\n  /** column name */\n  MatchAmount = 'matchAmount',\n  /** column name */\n  MatchAmountInUsd = 'matchAmountInUsd',\n  /** column name */\n  MatchTokenAddress = 'matchTokenAddress',\n  /** column name */\n  MatchingDistribution = 'matchingDistribution',\n  /** column name */\n  ProjectId = 'projectId',\n  /** column name */\n  ReadyForPayoutTransaction = 'readyForPayoutTransaction',\n  /** column name */\n  RoundMetadata = 'roundMetadata',\n  /** column name */\n  RoundMetadataCid = 'roundMetadataCid',\n  /** column name */\n  StrategyAddress = 'strategyAddress',\n  /** column name */\n  StrategyId = 'strategyId',\n  /** column name */\n  StrategyName = 'strategyName',\n  /** column name */\n  Tags = 'tags',\n  /** column name */\n  Timestamp = 'timestamp',\n  /** column name */\n  TotalAmountDonatedInUsd = 'totalAmountDonatedInUsd',\n  /** column name */\n  TotalDistributed = 'totalDistributed',\n  /** column name */\n  TotalDonationsCount = 'totalDonationsCount',\n  /** column name */\n  UniqueDonorsCount = 'uniqueDonorsCount',\n  /** column name */\n  UpdatedAtBlock = 'updatedAtBlock'\n}\n\n/** aggregate stddev on columns */\nexport type RoundsStddevFields = {\n  __typename?: 'RoundsStddevFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  fundedAmount?: Maybe<Scalars['Float']['output']>;\n  fundedAmountInUsd?: Maybe<Scalars['Float']['output']>;\n  matchAmount?: Maybe<Scalars['Float']['output']>;\n  matchAmountInUsd?: Maybe<Scalars['Float']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['Float']['output']>;\n  totalDistributed?: Maybe<Scalars['Float']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Float']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Float']['output']>;\n  updatedAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddev() on columns of table \"rounds\" */\nexport type RoundsStddevOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  fundedAmount?: InputMaybe<OrderBy>;\n  fundedAmountInUsd?: InputMaybe<OrderBy>;\n  matchAmount?: InputMaybe<OrderBy>;\n  matchAmountInUsd?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDistributed?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevPop on columns */\nexport type RoundsStddevPopFields = {\n  __typename?: 'RoundsStddevPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  fundedAmount?: Maybe<Scalars['Float']['output']>;\n  fundedAmountInUsd?: Maybe<Scalars['Float']['output']>;\n  matchAmount?: Maybe<Scalars['Float']['output']>;\n  matchAmountInUsd?: Maybe<Scalars['Float']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['Float']['output']>;\n  totalDistributed?: Maybe<Scalars['Float']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Float']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Float']['output']>;\n  updatedAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevPop() on columns of table \"rounds\" */\nexport type RoundsStddevPopOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  fundedAmount?: InputMaybe<OrderBy>;\n  fundedAmountInUsd?: InputMaybe<OrderBy>;\n  matchAmount?: InputMaybe<OrderBy>;\n  matchAmountInUsd?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDistributed?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddevSamp on columns */\nexport type RoundsStddevSampFields = {\n  __typename?: 'RoundsStddevSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  fundedAmount?: Maybe<Scalars['Float']['output']>;\n  fundedAmountInUsd?: Maybe<Scalars['Float']['output']>;\n  matchAmount?: Maybe<Scalars['Float']['output']>;\n  matchAmountInUsd?: Maybe<Scalars['Float']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['Float']['output']>;\n  totalDistributed?: Maybe<Scalars['Float']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Float']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Float']['output']>;\n  updatedAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by stddevSamp() on columns of table \"rounds\" */\nexport type RoundsStddevSampOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  fundedAmount?: InputMaybe<OrderBy>;\n  fundedAmountInUsd?: InputMaybe<OrderBy>;\n  matchAmount?: InputMaybe<OrderBy>;\n  matchAmountInUsd?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDistributed?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"rounds\" */\nexport type RoundsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initialValue: RoundsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type RoundsStreamCursorValueInput = {\n  adminRole?: InputMaybe<Scalars['String']['input']>;\n  applicationMetadata?: InputMaybe<Scalars['jsonb']['input']>;\n  applicationMetadataCid?: InputMaybe<Scalars['String']['input']>;\n  applicationsEndTime?: InputMaybe<Scalars['timestamptz']['input']>;\n  applicationsStartTime?: InputMaybe<Scalars['timestamptz']['input']>;\n  chainId?: InputMaybe<Scalars['Int']['input']>;\n  createdAtBlock?: InputMaybe<Scalars['numeric']['input']>;\n  createdByAddress?: InputMaybe<Scalars['String']['input']>;\n  donationsEndTime?: InputMaybe<Scalars['timestamptz']['input']>;\n  donationsStartTime?: InputMaybe<Scalars['timestamptz']['input']>;\n  fundedAmount?: InputMaybe<Scalars['numeric']['input']>;\n  fundedAmountInUsd?: InputMaybe<Scalars['numeric']['input']>;\n  id?: InputMaybe<Scalars['String']['input']>;\n  managerRole?: InputMaybe<Scalars['String']['input']>;\n  matchAmount?: InputMaybe<Scalars['numeric']['input']>;\n  matchAmountInUsd?: InputMaybe<Scalars['numeric']['input']>;\n  matchTokenAddress?: InputMaybe<Scalars['String']['input']>;\n  matchingDistribution?: InputMaybe<Scalars['jsonb']['input']>;\n  projectId?: InputMaybe<Scalars['String']['input']>;\n  readyForPayoutTransaction?: InputMaybe<Scalars['String']['input']>;\n  roundMetadata?: InputMaybe<Scalars['jsonb']['input']>;\n  roundMetadataCid?: InputMaybe<Scalars['String']['input']>;\n  strategyAddress?: InputMaybe<Scalars['String']['input']>;\n  strategyId?: InputMaybe<Scalars['String']['input']>;\n  strategyName?: InputMaybe<Scalars['String']['input']>;\n  tags?: InputMaybe<Scalars['jsonb']['input']>;\n  timestamp?: InputMaybe<Scalars['timestamptz']['input']>;\n  totalAmountDonatedInUsd?: InputMaybe<Scalars['numeric']['input']>;\n  totalDistributed?: InputMaybe<Scalars['numeric']['input']>;\n  totalDonationsCount?: InputMaybe<Scalars['Int']['input']>;\n  uniqueDonorsCount?: InputMaybe<Scalars['Int']['input']>;\n  updatedAtBlock?: InputMaybe<Scalars['numeric']['input']>;\n};\n\n/** aggregate sum on columns */\nexport type RoundsSumFields = {\n  __typename?: 'RoundsSumFields';\n  chainId?: Maybe<Scalars['Int']['output']>;\n  createdAtBlock?: Maybe<Scalars['numeric']['output']>;\n  fundedAmount?: Maybe<Scalars['numeric']['output']>;\n  fundedAmountInUsd?: Maybe<Scalars['numeric']['output']>;\n  matchAmount?: Maybe<Scalars['numeric']['output']>;\n  matchAmountInUsd?: Maybe<Scalars['numeric']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['numeric']['output']>;\n  totalDistributed?: Maybe<Scalars['numeric']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Int']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Int']['output']>;\n  updatedAtBlock?: Maybe<Scalars['numeric']['output']>;\n};\n\n/** order by sum() on columns of table \"rounds\" */\nexport type RoundsSumOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  fundedAmount?: InputMaybe<OrderBy>;\n  fundedAmountInUsd?: InputMaybe<OrderBy>;\n  matchAmount?: InputMaybe<OrderBy>;\n  matchAmountInUsd?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDistributed?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varPop on columns */\nexport type RoundsVarPopFields = {\n  __typename?: 'RoundsVarPopFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  fundedAmount?: Maybe<Scalars['Float']['output']>;\n  fundedAmountInUsd?: Maybe<Scalars['Float']['output']>;\n  matchAmount?: Maybe<Scalars['Float']['output']>;\n  matchAmountInUsd?: Maybe<Scalars['Float']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['Float']['output']>;\n  totalDistributed?: Maybe<Scalars['Float']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Float']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Float']['output']>;\n  updatedAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varPop() on columns of table \"rounds\" */\nexport type RoundsVarPopOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  fundedAmount?: InputMaybe<OrderBy>;\n  fundedAmountInUsd?: InputMaybe<OrderBy>;\n  matchAmount?: InputMaybe<OrderBy>;\n  matchAmountInUsd?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDistributed?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate varSamp on columns */\nexport type RoundsVarSampFields = {\n  __typename?: 'RoundsVarSampFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  fundedAmount?: Maybe<Scalars['Float']['output']>;\n  fundedAmountInUsd?: Maybe<Scalars['Float']['output']>;\n  matchAmount?: Maybe<Scalars['Float']['output']>;\n  matchAmountInUsd?: Maybe<Scalars['Float']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['Float']['output']>;\n  totalDistributed?: Maybe<Scalars['Float']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Float']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Float']['output']>;\n  updatedAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by varSamp() on columns of table \"rounds\" */\nexport type RoundsVarSampOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  fundedAmount?: InputMaybe<OrderBy>;\n  fundedAmountInUsd?: InputMaybe<OrderBy>;\n  matchAmount?: InputMaybe<OrderBy>;\n  matchAmountInUsd?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDistributed?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type RoundsVarianceFields = {\n  __typename?: 'RoundsVarianceFields';\n  chainId?: Maybe<Scalars['Float']['output']>;\n  createdAtBlock?: Maybe<Scalars['Float']['output']>;\n  fundedAmount?: Maybe<Scalars['Float']['output']>;\n  fundedAmountInUsd?: Maybe<Scalars['Float']['output']>;\n  matchAmount?: Maybe<Scalars['Float']['output']>;\n  matchAmountInUsd?: Maybe<Scalars['Float']['output']>;\n  totalAmountDonatedInUsd?: Maybe<Scalars['Float']['output']>;\n  totalDistributed?: Maybe<Scalars['Float']['output']>;\n  totalDonationsCount?: Maybe<Scalars['Float']['output']>;\n  uniqueDonorsCount?: Maybe<Scalars['Float']['output']>;\n  updatedAtBlock?: Maybe<Scalars['Float']['output']>;\n};\n\n/** order by variance() on columns of table \"rounds\" */\nexport type RoundsVarianceOrderBy = {\n  chainId?: InputMaybe<OrderBy>;\n  createdAtBlock?: InputMaybe<OrderBy>;\n  fundedAmount?: InputMaybe<OrderBy>;\n  fundedAmountInUsd?: InputMaybe<OrderBy>;\n  matchAmount?: InputMaybe<OrderBy>;\n  matchAmountInUsd?: InputMaybe<OrderBy>;\n  totalAmountDonatedInUsd?: InputMaybe<OrderBy>;\n  totalDistributed?: InputMaybe<OrderBy>;\n  totalDonationsCount?: InputMaybe<OrderBy>;\n  uniqueDonorsCount?: InputMaybe<OrderBy>;\n  updatedAtBlock?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'. */\nexport type StringComparisonExp = {\n  _eq?: InputMaybe<Scalars['String']['input']>;\n  _gt?: InputMaybe<Scalars['String']['input']>;\n  _gte?: InputMaybe<Scalars['String']['input']>;\n  /** does the column match the given case-insensitive pattern */\n  _ilike?: InputMaybe<Scalars['String']['input']>;\n  _in?: InputMaybe<Array<Scalars['String']['input']>>;\n  /** does the column match the given POSIX regular expression, case insensitive */\n  _iregex?: InputMaybe<Scalars['String']['input']>;\n  _isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  /** does the column match the given pattern */\n  _like?: InputMaybe<Scalars['String']['input']>;\n  _lt?: InputMaybe<Scalars['String']['input']>;\n  _lte?: InputMaybe<Scalars['String']['input']>;\n  _neq?: InputMaybe<Scalars['String']['input']>;\n  /** does the column NOT match the given case-insensitive pattern */\n  _nilike?: InputMaybe<Scalars['String']['input']>;\n  _nin?: InputMaybe<Array<Scalars['String']['input']>>;\n  /** does the column NOT match the given POSIX regular expression, case insensitive */\n  _niregex?: InputMaybe<Scalars['String']['input']>;\n  /** does the column NOT match the given pattern */\n  _nlike?: InputMaybe<Scalars['String']['input']>;\n  /** does the column NOT match the given POSIX regular expression, case sensitive */\n  _nregex?: InputMaybe<Scalars['String']['input']>;\n  /** does the column NOT match the given SQL regular expression */\n  _nsimilar?: InputMaybe<Scalars['String']['input']>;\n  /** does the column match the given POSIX regular expression, case sensitive */\n  _regex?: InputMaybe<Scalars['String']['input']>;\n  /** does the column match the given SQL regular expression */\n  _similar?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'. */\nexport type TimestamptzComparisonExp = {\n  _eq?: InputMaybe<Scalars['timestamptz']['input']>;\n  _gt?: InputMaybe<Scalars['timestamptz']['input']>;\n  _gte?: InputMaybe<Scalars['timestamptz']['input']>;\n  _in?: InputMaybe<Array<Scalars['timestamptz']['input']>>;\n  _isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  _lt?: InputMaybe<Scalars['timestamptz']['input']>;\n  _lte?: InputMaybe<Scalars['timestamptz']['input']>;\n  _neq?: InputMaybe<Scalars['timestamptz']['input']>;\n  _nin?: InputMaybe<Array<Scalars['timestamptz']['input']>>;\n};\n\nexport type ApplicationsAggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<ApplicationsSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n  filter?: InputMaybe<ApplicationsBoolExp>;\n  predicate: IntComparisonExp;\n};\n\nexport type ApplicationsPayoutsAggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<ApplicationsPayoutsSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n  filter?: InputMaybe<ApplicationsPayoutsBoolExp>;\n  predicate: IntComparisonExp;\n};\n\nexport type AttestationTxnsAggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<AttestationTxnsSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n  filter?: InputMaybe<AttestationTxnsBoolExp>;\n  predicate: IntComparisonExp;\n};\n\nexport type DonationsAggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<DonationsSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n  filter?: InputMaybe<DonationsBoolExp>;\n  predicate: IntComparisonExp;\n};\n\nexport type ProjectRolesAggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<ProjectRolesSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n  filter?: InputMaybe<ProjectRolesBoolExp>;\n  predicate: IntComparisonExp;\n};\n\nexport type ProjectsAggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<ProjectsSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n  filter?: InputMaybe<ProjectsBoolExp>;\n  predicate: IntComparisonExp;\n};\n\nexport type Query_Root = {\n  __typename?: 'query_root';\n  /** An array relationship */\n  applications: Array<Applications>;\n  /** An aggregate relationship */\n  applicationsAggregate: ApplicationsAggregate;\n  /** fetch data from the table: \"applications\" using primary key columns */\n  applicationsByPk?: Maybe<Applications>;\n  /** An array relationship */\n  applicationsPayouts: Array<ApplicationsPayouts>;\n  /** An aggregate relationship */\n  applicationsPayoutsAggregate: ApplicationsPayoutsAggregate;\n  /** fetch data from the table: \"applications_payouts\" using primary key columns */\n  applicationsPayoutsByPk?: Maybe<ApplicationsPayouts>;\n  /** An array relationship */\n  attestationTxns: Array<AttestationTxns>;\n  /** An aggregate relationship */\n  attestationTxnsAggregate: AttestationTxnsAggregate;\n  /** fetch data from the table: \"attestations\" */\n  attestations: Array<Attestations>;\n  /** fetch aggregated fields from the table: \"attestations\" */\n  attestationsAggregate: AttestationsAggregate;\n  /** fetch data from the table: \"attestations\" using primary key columns */\n  attestationsByPk?: Maybe<Attestations>;\n  /** An array relationship */\n  donations: Array<Donations>;\n  /** An aggregate relationship */\n  donationsAggregate: DonationsAggregate;\n  /** fetch data from the table: \"donations\" using primary key columns */\n  donationsByPk?: Maybe<Donations>;\n  /** fetch data from the table: \"events_registry\" */\n  eventsRegistry: Array<EventsRegistry>;\n  /** fetch aggregated fields from the table: \"events_registry\" */\n  eventsRegistryAggregate: EventsRegistryAggregate;\n  /** fetch data from the table: \"events_registry\" using primary key columns */\n  eventsRegistryByPk?: Maybe<EventsRegistry>;\n  /** fetch data from the table: \"legacy_projects\" */\n  legacyProjects: Array<LegacyProjects>;\n  /** fetch aggregated fields from the table: \"legacy_projects\" */\n  legacyProjectsAggregate: LegacyProjectsAggregate;\n  /** fetch data from the table: \"legacy_projects\" using primary key columns */\n  legacyProjectsByPk?: Maybe<LegacyProjects>;\n  /** fetch data from the table: \"pending_project_roles\" */\n  pendingProjectRoles: Array<PendingProjectRoles>;\n  /** fetch aggregated fields from the table: \"pending_project_roles\" */\n  pendingProjectRolesAggregate: PendingProjectRolesAggregate;\n  /** fetch data from the table: \"pending_project_roles\" using primary key columns */\n  pendingProjectRolesByPk?: Maybe<PendingProjectRoles>;\n  /** fetch data from the table: \"pending_round_roles\" */\n  pendingRoundRoles: Array<PendingRoundRoles>;\n  /** fetch aggregated fields from the table: \"pending_round_roles\" */\n  pendingRoundRolesAggregate: PendingRoundRolesAggregate;\n  /** fetch data from the table: \"pending_round_roles\" using primary key columns */\n  pendingRoundRolesByPk?: Maybe<PendingRoundRoles>;\n  /** An array relationship */\n  projectRoles: Array<ProjectRoles>;\n  /** An aggregate relationship */\n  projectRolesAggregate: ProjectRolesAggregate;\n  /** fetch data from the table: \"project_roles\" using primary key columns */\n  projectRolesByPk?: Maybe<ProjectRoles>;\n  /** An array relationship */\n  projects: Array<Projects>;\n  /** An aggregate relationship */\n  projectsAggregate: ProjectsAggregate;\n  /** fetch data from the table: \"projects\" using primary key columns */\n  projectsByPk?: Maybe<Projects>;\n  /** An array relationship */\n  roundRoles: Array<RoundRoles>;\n  /** An aggregate relationship */\n  roundRolesAggregate: RoundRolesAggregate;\n  /** fetch data from the table: \"round_roles\" using primary key columns */\n  roundRolesByPk?: Maybe<RoundRoles>;\n  /** An array relationship */\n  rounds: Array<Rounds>;\n  /** An aggregate relationship */\n  roundsAggregate: RoundsAggregate;\n  /** fetch data from the table: \"rounds\" using primary key columns */\n  roundsByPk?: Maybe<Rounds>;\n  /** execute function \"search_projects\" which returns \"projects\" */\n  searchProjects: Array<Projects>;\n  /** execute function \"search_projects\" and query aggregates on result of table type \"projects\" */\n  searchProjectsAggregate: ProjectsAggregate;\n};\n\n\nexport type Query_RootApplicationsArgs = {\n  distinctOn?: InputMaybe<Array<ApplicationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;\n  where?: InputMaybe<ApplicationsBoolExp>;\n};\n\n\nexport type Query_RootApplicationsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<ApplicationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;\n  where?: InputMaybe<ApplicationsBoolExp>;\n};\n\n\nexport type Query_RootApplicationsByPkArgs = {\n  chainId: Scalars['Int']['input'];\n  id: Scalars['String']['input'];\n  roundId: Scalars['String']['input'];\n};\n\n\nexport type Query_RootApplicationsPayoutsArgs = {\n  distinctOn?: InputMaybe<Array<ApplicationsPayoutsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ApplicationsPayoutsOrderBy>>;\n  where?: InputMaybe<ApplicationsPayoutsBoolExp>;\n};\n\n\nexport type Query_RootApplicationsPayoutsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<ApplicationsPayoutsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ApplicationsPayoutsOrderBy>>;\n  where?: InputMaybe<ApplicationsPayoutsBoolExp>;\n};\n\n\nexport type Query_RootApplicationsPayoutsByPkArgs = {\n  id: Scalars['Int']['input'];\n};\n\n\nexport type Query_RootAttestationTxnsArgs = {\n  distinctOn?: InputMaybe<Array<AttestationTxnsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<AttestationTxnsOrderBy>>;\n  where?: InputMaybe<AttestationTxnsBoolExp>;\n};\n\n\nexport type Query_RootAttestationTxnsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<AttestationTxnsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<AttestationTxnsOrderBy>>;\n  where?: InputMaybe<AttestationTxnsBoolExp>;\n};\n\n\nexport type Query_RootAttestationsArgs = {\n  distinctOn?: InputMaybe<Array<AttestationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<AttestationsOrderBy>>;\n  where?: InputMaybe<AttestationsBoolExp>;\n};\n\n\nexport type Query_RootAttestationsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<AttestationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<AttestationsOrderBy>>;\n  where?: InputMaybe<AttestationsBoolExp>;\n};\n\n\nexport type Query_RootAttestationsByPkArgs = {\n  chainId: Scalars['Int']['input'];\n  uid: Scalars['String']['input'];\n};\n\n\nexport type Query_RootDonationsArgs = {\n  distinctOn?: InputMaybe<Array<DonationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<DonationsOrderBy>>;\n  where?: InputMaybe<DonationsBoolExp>;\n};\n\n\nexport type Query_RootDonationsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<DonationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<DonationsOrderBy>>;\n  where?: InputMaybe<DonationsBoolExp>;\n};\n\n\nexport type Query_RootDonationsByPkArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type Query_RootEventsRegistryArgs = {\n  distinctOn?: InputMaybe<Array<EventsRegistrySelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<EventsRegistryOrderBy>>;\n  where?: InputMaybe<EventsRegistryBoolExp>;\n};\n\n\nexport type Query_RootEventsRegistryAggregateArgs = {\n  distinctOn?: InputMaybe<Array<EventsRegistrySelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<EventsRegistryOrderBy>>;\n  where?: InputMaybe<EventsRegistryBoolExp>;\n};\n\n\nexport type Query_RootEventsRegistryByPkArgs = {\n  chainId: Scalars['Int']['input'];\n};\n\n\nexport type Query_RootLegacyProjectsArgs = {\n  distinctOn?: InputMaybe<Array<LegacyProjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<LegacyProjectsOrderBy>>;\n  where?: InputMaybe<LegacyProjectsBoolExp>;\n};\n\n\nexport type Query_RootLegacyProjectsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<LegacyProjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<LegacyProjectsOrderBy>>;\n  where?: InputMaybe<LegacyProjectsBoolExp>;\n};\n\n\nexport type Query_RootLegacyProjectsByPkArgs = {\n  id: Scalars['Int']['input'];\n};\n\n\nexport type Query_RootPendingProjectRolesArgs = {\n  distinctOn?: InputMaybe<Array<PendingProjectRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<PendingProjectRolesOrderBy>>;\n  where?: InputMaybe<PendingProjectRolesBoolExp>;\n};\n\n\nexport type Query_RootPendingProjectRolesAggregateArgs = {\n  distinctOn?: InputMaybe<Array<PendingProjectRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<PendingProjectRolesOrderBy>>;\n  where?: InputMaybe<PendingProjectRolesBoolExp>;\n};\n\n\nexport type Query_RootPendingProjectRolesByPkArgs = {\n  id: Scalars['Int']['input'];\n};\n\n\nexport type Query_RootPendingRoundRolesArgs = {\n  distinctOn?: InputMaybe<Array<PendingRoundRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<PendingRoundRolesOrderBy>>;\n  where?: InputMaybe<PendingRoundRolesBoolExp>;\n};\n\n\nexport type Query_RootPendingRoundRolesAggregateArgs = {\n  distinctOn?: InputMaybe<Array<PendingRoundRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<PendingRoundRolesOrderBy>>;\n  where?: InputMaybe<PendingRoundRolesBoolExp>;\n};\n\n\nexport type Query_RootPendingRoundRolesByPkArgs = {\n  id: Scalars['Int']['input'];\n};\n\n\nexport type Query_RootProjectRolesArgs = {\n  distinctOn?: InputMaybe<Array<ProjectRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectRolesOrderBy>>;\n  where?: InputMaybe<ProjectRolesBoolExp>;\n};\n\n\nexport type Query_RootProjectRolesAggregateArgs = {\n  distinctOn?: InputMaybe<Array<ProjectRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectRolesOrderBy>>;\n  where?: InputMaybe<ProjectRolesBoolExp>;\n};\n\n\nexport type Query_RootProjectRolesByPkArgs = {\n  address: Scalars['String']['input'];\n  chainId: Scalars['Int']['input'];\n  projectId: Scalars['String']['input'];\n  role: Scalars['project_role_name']['input'];\n};\n\n\nexport type Query_RootProjectsArgs = {\n  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;\n  where?: InputMaybe<ProjectsBoolExp>;\n};\n\n\nexport type Query_RootProjectsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;\n  where?: InputMaybe<ProjectsBoolExp>;\n};\n\n\nexport type Query_RootProjectsByPkArgs = {\n  chainId: Scalars['Int']['input'];\n  id: Scalars['String']['input'];\n};\n\n\nexport type Query_RootRoundRolesArgs = {\n  distinctOn?: InputMaybe<Array<RoundRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<RoundRolesOrderBy>>;\n  where?: InputMaybe<RoundRolesBoolExp>;\n};\n\n\nexport type Query_RootRoundRolesAggregateArgs = {\n  distinctOn?: InputMaybe<Array<RoundRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<RoundRolesOrderBy>>;\n  where?: InputMaybe<RoundRolesBoolExp>;\n};\n\n\nexport type Query_RootRoundRolesByPkArgs = {\n  address: Scalars['String']['input'];\n  chainId: Scalars['Int']['input'];\n  role: Scalars['round_role_name']['input'];\n  roundId: Scalars['String']['input'];\n};\n\n\nexport type Query_RootRoundsArgs = {\n  distinctOn?: InputMaybe<Array<RoundsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<RoundsOrderBy>>;\n  where?: InputMaybe<RoundsBoolExp>;\n};\n\n\nexport type Query_RootRoundsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<RoundsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<RoundsOrderBy>>;\n  where?: InputMaybe<RoundsBoolExp>;\n};\n\n\nexport type Query_RootRoundsByPkArgs = {\n  chainId: Scalars['Int']['input'];\n  id: Scalars['String']['input'];\n};\n\n\nexport type Query_RootSearchProjectsArgs = {\n  args: SearchProjectsArgs;\n  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;\n  where?: InputMaybe<ProjectsBoolExp>;\n};\n\n\nexport type Query_RootSearchProjectsAggregateArgs = {\n  args: SearchProjectsArgs;\n  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;\n  where?: InputMaybe<ProjectsBoolExp>;\n};\n\nexport type RoundRolesAggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<RoundRolesSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n  filter?: InputMaybe<RoundRolesBoolExp>;\n  predicate: IntComparisonExp;\n};\n\nexport type RoundsAggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<RoundsSelectColumn>>;\n  distinct?: InputMaybe<Scalars['Boolean']['input']>;\n  filter?: InputMaybe<RoundsBoolExp>;\n  predicate: IntComparisonExp;\n};\n\nexport type SearchProjectsArgs = {\n  search_term?: InputMaybe<Scalars['String']['input']>;\n};\n\nexport type Subscription_Root = {\n  __typename?: 'subscription_root';\n  /** An array relationship */\n  applications: Array<Applications>;\n  /** An aggregate relationship */\n  applicationsAggregate: ApplicationsAggregate;\n  /** fetch data from the table: \"applications\" using primary key columns */\n  applicationsByPk?: Maybe<Applications>;\n  /** An array relationship */\n  applicationsPayouts: Array<ApplicationsPayouts>;\n  /** An aggregate relationship */\n  applicationsPayoutsAggregate: ApplicationsPayoutsAggregate;\n  /** fetch data from the table: \"applications_payouts\" using primary key columns */\n  applicationsPayoutsByPk?: Maybe<ApplicationsPayouts>;\n  /** fetch data from the table in a streaming manner: \"applications_payouts\" */\n  applicationsPayoutsStream: Array<ApplicationsPayouts>;\n  /** fetch data from the table in a streaming manner: \"applications\" */\n  applicationsStream: Array<Applications>;\n  /** An array relationship */\n  attestationTxns: Array<AttestationTxns>;\n  /** An aggregate relationship */\n  attestationTxnsAggregate: AttestationTxnsAggregate;\n  /** fetch data from the table in a streaming manner: \"attestation_txns\" */\n  attestationTxnsStream: Array<AttestationTxns>;\n  /** fetch data from the table: \"attestations\" */\n  attestations: Array<Attestations>;\n  /** fetch aggregated fields from the table: \"attestations\" */\n  attestationsAggregate: AttestationsAggregate;\n  /** fetch data from the table: \"attestations\" using primary key columns */\n  attestationsByPk?: Maybe<Attestations>;\n  /** fetch data from the table in a streaming manner: \"attestations\" */\n  attestationsStream: Array<Attestations>;\n  /** An array relationship */\n  donations: Array<Donations>;\n  /** An aggregate relationship */\n  donationsAggregate: DonationsAggregate;\n  /** fetch data from the table: \"donations\" using primary key columns */\n  donationsByPk?: Maybe<Donations>;\n  /** fetch data from the table in a streaming manner: \"donations\" */\n  donationsStream: Array<Donations>;\n  /** fetch data from the table: \"events_registry\" */\n  eventsRegistry: Array<EventsRegistry>;\n  /** fetch aggregated fields from the table: \"events_registry\" */\n  eventsRegistryAggregate: EventsRegistryAggregate;\n  /** fetch data from the table: \"events_registry\" using primary key columns */\n  eventsRegistryByPk?: Maybe<EventsRegistry>;\n  /** fetch data from the table in a streaming manner: \"events_registry\" */\n  eventsRegistryStream: Array<EventsRegistry>;\n  /** fetch data from the table: \"legacy_projects\" */\n  legacyProjects: Array<LegacyProjects>;\n  /** fetch aggregated fields from the table: \"legacy_projects\" */\n  legacyProjectsAggregate: LegacyProjectsAggregate;\n  /** fetch data from the table: \"legacy_projects\" using primary key columns */\n  legacyProjectsByPk?: Maybe<LegacyProjects>;\n  /** fetch data from the table in a streaming manner: \"legacy_projects\" */\n  legacyProjectsStream: Array<LegacyProjects>;\n  /** fetch data from the table: \"pending_project_roles\" */\n  pendingProjectRoles: Array<PendingProjectRoles>;\n  /** fetch aggregated fields from the table: \"pending_project_roles\" */\n  pendingProjectRolesAggregate: PendingProjectRolesAggregate;\n  /** fetch data from the table: \"pending_project_roles\" using primary key columns */\n  pendingProjectRolesByPk?: Maybe<PendingProjectRoles>;\n  /** fetch data from the table in a streaming manner: \"pending_project_roles\" */\n  pendingProjectRolesStream: Array<PendingProjectRoles>;\n  /** fetch data from the table: \"pending_round_roles\" */\n  pendingRoundRoles: Array<PendingRoundRoles>;\n  /** fetch aggregated fields from the table: \"pending_round_roles\" */\n  pendingRoundRolesAggregate: PendingRoundRolesAggregate;\n  /** fetch data from the table: \"pending_round_roles\" using primary key columns */\n  pendingRoundRolesByPk?: Maybe<PendingRoundRoles>;\n  /** fetch data from the table in a streaming manner: \"pending_round_roles\" */\n  pendingRoundRolesStream: Array<PendingRoundRoles>;\n  /** An array relationship */\n  projectRoles: Array<ProjectRoles>;\n  /** An aggregate relationship */\n  projectRolesAggregate: ProjectRolesAggregate;\n  /** fetch data from the table: \"project_roles\" using primary key columns */\n  projectRolesByPk?: Maybe<ProjectRoles>;\n  /** fetch data from the table in a streaming manner: \"project_roles\" */\n  projectRolesStream: Array<ProjectRoles>;\n  /** An array relationship */\n  projects: Array<Projects>;\n  /** An aggregate relationship */\n  projectsAggregate: ProjectsAggregate;\n  /** fetch data from the table: \"projects\" using primary key columns */\n  projectsByPk?: Maybe<Projects>;\n  /** fetch data from the table in a streaming manner: \"projects\" */\n  projectsStream: Array<Projects>;\n  /** An array relationship */\n  roundRoles: Array<RoundRoles>;\n  /** An aggregate relationship */\n  roundRolesAggregate: RoundRolesAggregate;\n  /** fetch data from the table: \"round_roles\" using primary key columns */\n  roundRolesByPk?: Maybe<RoundRoles>;\n  /** fetch data from the table in a streaming manner: \"round_roles\" */\n  roundRolesStream: Array<RoundRoles>;\n  /** An array relationship */\n  rounds: Array<Rounds>;\n  /** An aggregate relationship */\n  roundsAggregate: RoundsAggregate;\n  /** fetch data from the table: \"rounds\" using primary key columns */\n  roundsByPk?: Maybe<Rounds>;\n  /** fetch data from the table in a streaming manner: \"rounds\" */\n  roundsStream: Array<Rounds>;\n  /** execute function \"search_projects\" which returns \"projects\" */\n  searchProjects: Array<Projects>;\n  /** execute function \"search_projects\" and query aggregates on result of table type \"projects\" */\n  searchProjectsAggregate: ProjectsAggregate;\n};\n\n\nexport type Subscription_RootApplicationsArgs = {\n  distinctOn?: InputMaybe<Array<ApplicationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;\n  where?: InputMaybe<ApplicationsBoolExp>;\n};\n\n\nexport type Subscription_RootApplicationsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<ApplicationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;\n  where?: InputMaybe<ApplicationsBoolExp>;\n};\n\n\nexport type Subscription_RootApplicationsByPkArgs = {\n  chainId: Scalars['Int']['input'];\n  id: Scalars['String']['input'];\n  roundId: Scalars['String']['input'];\n};\n\n\nexport type Subscription_RootApplicationsPayoutsArgs = {\n  distinctOn?: InputMaybe<Array<ApplicationsPayoutsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ApplicationsPayoutsOrderBy>>;\n  where?: InputMaybe<ApplicationsPayoutsBoolExp>;\n};\n\n\nexport type Subscription_RootApplicationsPayoutsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<ApplicationsPayoutsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ApplicationsPayoutsOrderBy>>;\n  where?: InputMaybe<ApplicationsPayoutsBoolExp>;\n};\n\n\nexport type Subscription_RootApplicationsPayoutsByPkArgs = {\n  id: Scalars['Int']['input'];\n};\n\n\nexport type Subscription_RootApplicationsPayoutsStreamArgs = {\n  batchSize: Scalars['Int']['input'];\n  cursor: Array<InputMaybe<ApplicationsPayoutsStreamCursorInput>>;\n  where?: InputMaybe<ApplicationsPayoutsBoolExp>;\n};\n\n\nexport type Subscription_RootApplicationsStreamArgs = {\n  batchSize: Scalars['Int']['input'];\n  cursor: Array<InputMaybe<ApplicationsStreamCursorInput>>;\n  where?: InputMaybe<ApplicationsBoolExp>;\n};\n\n\nexport type Subscription_RootAttestationTxnsArgs = {\n  distinctOn?: InputMaybe<Array<AttestationTxnsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<AttestationTxnsOrderBy>>;\n  where?: InputMaybe<AttestationTxnsBoolExp>;\n};\n\n\nexport type Subscription_RootAttestationTxnsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<AttestationTxnsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<AttestationTxnsOrderBy>>;\n  where?: InputMaybe<AttestationTxnsBoolExp>;\n};\n\n\nexport type Subscription_RootAttestationTxnsStreamArgs = {\n  batchSize: Scalars['Int']['input'];\n  cursor: Array<InputMaybe<AttestationTxnsStreamCursorInput>>;\n  where?: InputMaybe<AttestationTxnsBoolExp>;\n};\n\n\nexport type Subscription_RootAttestationsArgs = {\n  distinctOn?: InputMaybe<Array<AttestationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<AttestationsOrderBy>>;\n  where?: InputMaybe<AttestationsBoolExp>;\n};\n\n\nexport type Subscription_RootAttestationsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<AttestationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<AttestationsOrderBy>>;\n  where?: InputMaybe<AttestationsBoolExp>;\n};\n\n\nexport type Subscription_RootAttestationsByPkArgs = {\n  chainId: Scalars['Int']['input'];\n  uid: Scalars['String']['input'];\n};\n\n\nexport type Subscription_RootAttestationsStreamArgs = {\n  batchSize: Scalars['Int']['input'];\n  cursor: Array<InputMaybe<AttestationsStreamCursorInput>>;\n  where?: InputMaybe<AttestationsBoolExp>;\n};\n\n\nexport type Subscription_RootDonationsArgs = {\n  distinctOn?: InputMaybe<Array<DonationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<DonationsOrderBy>>;\n  where?: InputMaybe<DonationsBoolExp>;\n};\n\n\nexport type Subscription_RootDonationsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<DonationsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<DonationsOrderBy>>;\n  where?: InputMaybe<DonationsBoolExp>;\n};\n\n\nexport type Subscription_RootDonationsByPkArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type Subscription_RootDonationsStreamArgs = {\n  batchSize: Scalars['Int']['input'];\n  cursor: Array<InputMaybe<DonationsStreamCursorInput>>;\n  where?: InputMaybe<DonationsBoolExp>;\n};\n\n\nexport type Subscription_RootEventsRegistryArgs = {\n  distinctOn?: InputMaybe<Array<EventsRegistrySelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<EventsRegistryOrderBy>>;\n  where?: InputMaybe<EventsRegistryBoolExp>;\n};\n\n\nexport type Subscription_RootEventsRegistryAggregateArgs = {\n  distinctOn?: InputMaybe<Array<EventsRegistrySelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<EventsRegistryOrderBy>>;\n  where?: InputMaybe<EventsRegistryBoolExp>;\n};\n\n\nexport type Subscription_RootEventsRegistryByPkArgs = {\n  chainId: Scalars['Int']['input'];\n};\n\n\nexport type Subscription_RootEventsRegistryStreamArgs = {\n  batchSize: Scalars['Int']['input'];\n  cursor: Array<InputMaybe<EventsRegistryStreamCursorInput>>;\n  where?: InputMaybe<EventsRegistryBoolExp>;\n};\n\n\nexport type Subscription_RootLegacyProjectsArgs = {\n  distinctOn?: InputMaybe<Array<LegacyProjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<LegacyProjectsOrderBy>>;\n  where?: InputMaybe<LegacyProjectsBoolExp>;\n};\n\n\nexport type Subscription_RootLegacyProjectsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<LegacyProjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<LegacyProjectsOrderBy>>;\n  where?: InputMaybe<LegacyProjectsBoolExp>;\n};\n\n\nexport type Subscription_RootLegacyProjectsByPkArgs = {\n  id: Scalars['Int']['input'];\n};\n\n\nexport type Subscription_RootLegacyProjectsStreamArgs = {\n  batchSize: Scalars['Int']['input'];\n  cursor: Array<InputMaybe<LegacyProjectsStreamCursorInput>>;\n  where?: InputMaybe<LegacyProjectsBoolExp>;\n};\n\n\nexport type Subscription_RootPendingProjectRolesArgs = {\n  distinctOn?: InputMaybe<Array<PendingProjectRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<PendingProjectRolesOrderBy>>;\n  where?: InputMaybe<PendingProjectRolesBoolExp>;\n};\n\n\nexport type Subscription_RootPendingProjectRolesAggregateArgs = {\n  distinctOn?: InputMaybe<Array<PendingProjectRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<PendingProjectRolesOrderBy>>;\n  where?: InputMaybe<PendingProjectRolesBoolExp>;\n};\n\n\nexport type Subscription_RootPendingProjectRolesByPkArgs = {\n  id: Scalars['Int']['input'];\n};\n\n\nexport type Subscription_RootPendingProjectRolesStreamArgs = {\n  batchSize: Scalars['Int']['input'];\n  cursor: Array<InputMaybe<PendingProjectRolesStreamCursorInput>>;\n  where?: InputMaybe<PendingProjectRolesBoolExp>;\n};\n\n\nexport type Subscription_RootPendingRoundRolesArgs = {\n  distinctOn?: InputMaybe<Array<PendingRoundRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<PendingRoundRolesOrderBy>>;\n  where?: InputMaybe<PendingRoundRolesBoolExp>;\n};\n\n\nexport type Subscription_RootPendingRoundRolesAggregateArgs = {\n  distinctOn?: InputMaybe<Array<PendingRoundRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<PendingRoundRolesOrderBy>>;\n  where?: InputMaybe<PendingRoundRolesBoolExp>;\n};\n\n\nexport type Subscription_RootPendingRoundRolesByPkArgs = {\n  id: Scalars['Int']['input'];\n};\n\n\nexport type Subscription_RootPendingRoundRolesStreamArgs = {\n  batchSize: Scalars['Int']['input'];\n  cursor: Array<InputMaybe<PendingRoundRolesStreamCursorInput>>;\n  where?: InputMaybe<PendingRoundRolesBoolExp>;\n};\n\n\nexport type Subscription_RootProjectRolesArgs = {\n  distinctOn?: InputMaybe<Array<ProjectRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectRolesOrderBy>>;\n  where?: InputMaybe<ProjectRolesBoolExp>;\n};\n\n\nexport type Subscription_RootProjectRolesAggregateArgs = {\n  distinctOn?: InputMaybe<Array<ProjectRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectRolesOrderBy>>;\n  where?: InputMaybe<ProjectRolesBoolExp>;\n};\n\n\nexport type Subscription_RootProjectRolesByPkArgs = {\n  address: Scalars['String']['input'];\n  chainId: Scalars['Int']['input'];\n  projectId: Scalars['String']['input'];\n  role: Scalars['project_role_name']['input'];\n};\n\n\nexport type Subscription_RootProjectRolesStreamArgs = {\n  batchSize: Scalars['Int']['input'];\n  cursor: Array<InputMaybe<ProjectRolesStreamCursorInput>>;\n  where?: InputMaybe<ProjectRolesBoolExp>;\n};\n\n\nexport type Subscription_RootProjectsArgs = {\n  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;\n  where?: InputMaybe<ProjectsBoolExp>;\n};\n\n\nexport type Subscription_RootProjectsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;\n  where?: InputMaybe<ProjectsBoolExp>;\n};\n\n\nexport type Subscription_RootProjectsByPkArgs = {\n  chainId: Scalars['Int']['input'];\n  id: Scalars['String']['input'];\n};\n\n\nexport type Subscription_RootProjectsStreamArgs = {\n  batchSize: Scalars['Int']['input'];\n  cursor: Array<InputMaybe<ProjectsStreamCursorInput>>;\n  where?: InputMaybe<ProjectsBoolExp>;\n};\n\n\nexport type Subscription_RootRoundRolesArgs = {\n  distinctOn?: InputMaybe<Array<RoundRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<RoundRolesOrderBy>>;\n  where?: InputMaybe<RoundRolesBoolExp>;\n};\n\n\nexport type Subscription_RootRoundRolesAggregateArgs = {\n  distinctOn?: InputMaybe<Array<RoundRolesSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<RoundRolesOrderBy>>;\n  where?: InputMaybe<RoundRolesBoolExp>;\n};\n\n\nexport type Subscription_RootRoundRolesByPkArgs = {\n  address: Scalars['String']['input'];\n  chainId: Scalars['Int']['input'];\n  role: Scalars['round_role_name']['input'];\n  roundId: Scalars['String']['input'];\n};\n\n\nexport type Subscription_RootRoundRolesStreamArgs = {\n  batchSize: Scalars['Int']['input'];\n  cursor: Array<InputMaybe<RoundRolesStreamCursorInput>>;\n  where?: InputMaybe<RoundRolesBoolExp>;\n};\n\n\nexport type Subscription_RootRoundsArgs = {\n  distinctOn?: InputMaybe<Array<RoundsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<RoundsOrderBy>>;\n  where?: InputMaybe<RoundsBoolExp>;\n};\n\n\nexport type Subscription_RootRoundsAggregateArgs = {\n  distinctOn?: InputMaybe<Array<RoundsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<RoundsOrderBy>>;\n  where?: InputMaybe<RoundsBoolExp>;\n};\n\n\nexport type Subscription_RootRoundsByPkArgs = {\n  chainId: Scalars['Int']['input'];\n  id: Scalars['String']['input'];\n};\n\n\nexport type Subscription_RootRoundsStreamArgs = {\n  batchSize: Scalars['Int']['input'];\n  cursor: Array<InputMaybe<RoundsStreamCursorInput>>;\n  where?: InputMaybe<RoundsBoolExp>;\n};\n\n\nexport type Subscription_RootSearchProjectsArgs = {\n  args: SearchProjectsArgs;\n  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;\n  where?: InputMaybe<ProjectsBoolExp>;\n};\n\n\nexport type Subscription_RootSearchProjectsAggregateArgs = {\n  args: SearchProjectsArgs;\n  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;\n  where?: InputMaybe<ProjectsBoolExp>;\n};\n"